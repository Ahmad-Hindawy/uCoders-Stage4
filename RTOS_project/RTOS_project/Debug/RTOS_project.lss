
RTOS_project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001578  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002c  00800060  00001578  0000160c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000672  0080008c  0080008c  00001638  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001638  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001668  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002e8  00000000  00000000  000016a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000031c7  00000000  00000000  0000198c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001078  00000000  00000000  00004b53  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001d03  00000000  00000000  00005bcb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000734  00000000  00000000  000078d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000f15  00000000  00000000  00008004  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000024c5  00000000  00000000  00008f19  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000288  00000000  00000000  0000b3de  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3a 00 	jmp	0x74	; 0x74 <__ctors_end>
       4:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
       8:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
       c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      10:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      14:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      18:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      1c:	0c 94 ac 03 	jmp	0x758	; 0x758 <__vector_7>
      20:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      24:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      28:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      2c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      30:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      34:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      38:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      3c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      40:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      44:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      48:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      4c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      50:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      54:	fe 00       	.word	0x00fe	; ????
      56:	de 00       	.word	0x00de	; ????
      58:	e0 00       	.word	0x00e0	; ????
      5a:	e2 00       	.word	0x00e2	; ????
      5c:	e4 00       	.word	0x00e4	; ????
      5e:	e6 00       	.word	0x00e6	; ????
      60:	e8 00       	.word	0x00e8	; ????
      62:	ea 00       	.word	0x00ea	; ????
      64:	ec 00       	.word	0x00ec	; ????
      66:	ee 00       	.word	0x00ee	; ????
      68:	f0 00       	.word	0x00f0	; ????
      6a:	f2 00       	.word	0x00f2	; ????
      6c:	f4 00       	.word	0x00f4	; ????
      6e:	f6 00       	.word	0x00f6	; ????
      70:	f8 00       	.word	0x00f8	; ????
      72:	fa 00       	.word	0x00fa	; ????

00000074 <__ctors_end>:
      74:	11 24       	eor	r1, r1
      76:	1f be       	out	0x3f, r1	; 63
      78:	cf e5       	ldi	r28, 0x5F	; 95
      7a:	d8 e0       	ldi	r29, 0x08	; 8
      7c:	de bf       	out	0x3e, r29	; 62
      7e:	cd bf       	out	0x3d, r28	; 61

00000080 <__do_copy_data>:
      80:	10 e0       	ldi	r17, 0x00	; 0
      82:	a0 e6       	ldi	r26, 0x60	; 96
      84:	b0 e0       	ldi	r27, 0x00	; 0
      86:	e8 e7       	ldi	r30, 0x78	; 120
      88:	f5 e1       	ldi	r31, 0x15	; 21
      8a:	02 c0       	rjmp	.+4      	; 0x90 <__do_copy_data+0x10>
      8c:	05 90       	lpm	r0, Z+
      8e:	0d 92       	st	X+, r0
      90:	ac 38       	cpi	r26, 0x8C	; 140
      92:	b1 07       	cpc	r27, r17
      94:	d9 f7       	brne	.-10     	; 0x8c <__do_copy_data+0xc>

00000096 <__do_clear_bss>:
      96:	26 e0       	ldi	r18, 0x06	; 6
      98:	ac e8       	ldi	r26, 0x8C	; 140
      9a:	b0 e0       	ldi	r27, 0x00	; 0
      9c:	01 c0       	rjmp	.+2      	; 0xa0 <.do_clear_bss_start>

0000009e <.do_clear_bss_loop>:
      9e:	1d 92       	st	X+, r1

000000a0 <.do_clear_bss_start>:
      a0:	ae 3f       	cpi	r26, 0xFE	; 254
      a2:	b2 07       	cpc	r27, r18
      a4:	e1 f7       	brne	.-8      	; 0x9e <.do_clear_bss_loop>
      a6:	0e 94 4f 06 	call	0xc9e	; 0xc9e <main>
      aa:	0c 94 ba 0a 	jmp	0x1574	; 0x1574 <_exit>

000000ae <__bad_interrupt>:
      ae:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b2 <DIO_voidInt>:
        if(GETBIT(PIND,local_pinNumber-24) == 1)
                return DIO_HIGH;
            else if(GETBIT(PIND,local_pinNumber-24) == 0)
                return DIO_LOW;
    }
}
      b2:	8f ef       	ldi	r24, 0xFF	; 255
      b4:	8a bb       	out	0x1a, r24	; 26
      b6:	87 bb       	out	0x17, r24	; 23
      b8:	84 bb       	out	0x14, r24	; 20
      ba:	81 bb       	out	0x11, r24	; 17
      bc:	08 95       	ret

000000be <DIO_voidSetPortDir>:
      be:	81 11       	cpse	r24, r1
      c0:	02 c0       	rjmp	.+4      	; 0xc6 <DIO_voidSetPortDir+0x8>
      c2:	6a bb       	out	0x1a, r22	; 26
      c4:	08 95       	ret
      c6:	81 30       	cpi	r24, 0x01	; 1
      c8:	11 f4       	brne	.+4      	; 0xce <DIO_voidSetPortDir+0x10>
      ca:	67 bb       	out	0x17, r22	; 23
      cc:	08 95       	ret
      ce:	82 30       	cpi	r24, 0x02	; 2
      d0:	11 f4       	brne	.+4      	; 0xd6 <DIO_voidSetPortDir+0x18>
      d2:	64 bb       	out	0x14, r22	; 20
      d4:	08 95       	ret
      d6:	83 30       	cpi	r24, 0x03	; 3
      d8:	09 f4       	brne	.+2      	; 0xdc <DIO_voidSetPortDir+0x1e>
      da:	61 bb       	out	0x11, r22	; 17
      dc:	08 95       	ret

000000de <DIO_voidSetPort>:
      de:	81 11       	cpse	r24, r1
      e0:	02 c0       	rjmp	.+4      	; 0xe6 <DIO_voidSetPort+0x8>
      e2:	6b bb       	out	0x1b, r22	; 27
      e4:	08 95       	ret
      e6:	81 30       	cpi	r24, 0x01	; 1
      e8:	11 f4       	brne	.+4      	; 0xee <DIO_voidSetPort+0x10>
      ea:	68 bb       	out	0x18, r22	; 24
      ec:	08 95       	ret
      ee:	82 30       	cpi	r24, 0x02	; 2
      f0:	11 f4       	brne	.+4      	; 0xf6 <DIO_voidSetPort+0x18>
      f2:	65 bb       	out	0x15, r22	; 21
      f4:	08 95       	ret
      f6:	83 30       	cpi	r24, 0x03	; 3
      f8:	09 f4       	brne	.+2      	; 0xfc <DIO_voidSetPort+0x1e>
      fa:	62 bb       	out	0x12, r22	; 18
      fc:	08 95       	ret

000000fe <DIO_u8GetPinInPort>:

u8 DIO_u8GetPinInPort(u8 Local_PortNumber, u8 Local_PinNumber)
{
    u8 ret=DIO_LOW;

    if(Local_PortNumber == 0)
      fe:	81 11       	cpse	r24, r1
     100:	09 c0       	rjmp	.+18     	; 0x114 <DIO_u8GetPinInPort+0x16>
	{
	    ret = GETBIT(PINA, Local_PinNumber);
     102:	89 b3       	in	r24, 0x19	; 25
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	02 c0       	rjmp	.+4      	; 0x10c <DIO_u8GetPinInPort+0xe>
     108:	95 95       	asr	r25
     10a:	87 95       	ror	r24
     10c:	6a 95       	dec	r22
     10e:	e2 f7       	brpl	.-8      	; 0x108 <DIO_u8GetPinInPort+0xa>
     110:	81 70       	andi	r24, 0x01	; 1
     112:	08 95       	ret

    }else if(Local_PortNumber == 1)
     114:	81 30       	cpi	r24, 0x01	; 1
     116:	49 f4       	brne	.+18     	; 0x12a <DIO_u8GetPinInPort+0x2c>
    {
	    ret = GETBIT(PINB, Local_PinNumber);
     118:	86 b3       	in	r24, 0x16	; 22
     11a:	90 e0       	ldi	r25, 0x00	; 0
     11c:	02 c0       	rjmp	.+4      	; 0x122 <DIO_u8GetPinInPort+0x24>
     11e:	95 95       	asr	r25
     120:	87 95       	ror	r24
     122:	6a 95       	dec	r22
     124:	e2 f7       	brpl	.-8      	; 0x11e <DIO_u8GetPinInPort+0x20>
     126:	81 70       	andi	r24, 0x01	; 1
     128:	08 95       	ret

    }else if(Local_PortNumber == 2)
     12a:	82 30       	cpi	r24, 0x02	; 2
     12c:	49 f4       	brne	.+18     	; 0x140 <DIO_u8GetPinInPort+0x42>
    {
	    ret = GETBIT(PINC, Local_PinNumber);
     12e:	83 b3       	in	r24, 0x13	; 19
     130:	90 e0       	ldi	r25, 0x00	; 0
     132:	02 c0       	rjmp	.+4      	; 0x138 <DIO_u8GetPinInPort+0x3a>
     134:	95 95       	asr	r25
     136:	87 95       	ror	r24
     138:	6a 95       	dec	r22
     13a:	e2 f7       	brpl	.-8      	; 0x134 <DIO_u8GetPinInPort+0x36>
     13c:	81 70       	andi	r24, 0x01	; 1
     13e:	08 95       	ret

    }else if(Local_PortNumber == 3)
     140:	83 30       	cpi	r24, 0x03	; 3
     142:	49 f4       	brne	.+18     	; 0x156 <DIO_u8GetPinInPort+0x58>
    {
	    ret = GETBIT(PIND, Local_PinNumber);
     144:	80 b3       	in	r24, 0x10	; 16
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	02 c0       	rjmp	.+4      	; 0x14e <DIO_u8GetPinInPort+0x50>
     14a:	95 95       	asr	r25
     14c:	87 95       	ror	r24
     14e:	6a 95       	dec	r22
     150:	e2 f7       	brpl	.-8      	; 0x14a <DIO_u8GetPinInPort+0x4c>
     152:	81 70       	andi	r24, 0x01	; 1
     154:	08 95       	ret
    }
}

u8 DIO_u8GetPinInPort(u8 Local_PortNumber, u8 Local_PinNumber)
{
    u8 ret=DIO_LOW;
     156:	80 e0       	ldi	r24, 0x00	; 0
	    ret = GETBIT(PIND, Local_PinNumber);
    }

    return ret;

}
     158:	08 95       	ret

0000015a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     15a:	cf 93       	push	r28
     15c:	df 93       	push	r29
     15e:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     160:	0e 94 36 08 	call	0x106c	; 0x106c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     164:	20 91 8c 00 	lds	r18, 0x008C	; 0x80008c <__data_end>
     168:	30 91 8d 00 	lds	r19, 0x008D	; 0x80008d <__data_end+0x1>
     16c:	c9 01       	movw	r24, r18
     16e:	8c 0f       	add	r24, r28
     170:	9d 1f       	adc	r25, r29
     172:	8c 3d       	cpi	r24, 0xDC	; 220
     174:	45 e0       	ldi	r20, 0x05	; 5
     176:	94 07       	cpc	r25, r20
     178:	58 f4       	brcc	.+22     	; 0x190 <pvPortMalloc+0x36>
     17a:	28 17       	cp	r18, r24
     17c:	39 07       	cpc	r19, r25
     17e:	58 f4       	brcc	.+22     	; 0x196 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     180:	e9 01       	movw	r28, r18
     182:	c2 57       	subi	r28, 0x72	; 114
     184:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     186:	90 93 8d 00 	sts	0x008D, r25	; 0x80008d <__data_end+0x1>
     18a:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <__data_end>
     18e:	05 c0       	rjmp	.+10     	; 0x19a <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     190:	c0 e0       	ldi	r28, 0x00	; 0
     192:	d0 e0       	ldi	r29, 0x00	; 0
     194:	02 c0       	rjmp	.+4      	; 0x19a <pvPortMalloc+0x40>
     196:	c0 e0       	ldi	r28, 0x00	; 0
     198:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     19a:	0e 94 0a 09 	call	0x1214	; 0x1214 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     19e:	ce 01       	movw	r24, r28
     1a0:	df 91       	pop	r29
     1a2:	cf 91       	pop	r28
     1a4:	08 95       	ret

000001a6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     1a6:	08 95       	ret

000001a8 <KeyPad_u8AdjustKeyNumber_4x4>:

}

u8 KeyPad_u8AdjustKeyNumber_4x4(u8 button_number)
{
    switch(button_number)
     1a8:	90 e0       	ldi	r25, 0x00	; 0
     1aa:	fc 01       	movw	r30, r24
     1ac:	31 97       	sbiw	r30, 0x01	; 1
     1ae:	e0 31       	cpi	r30, 0x10	; 16
     1b0:	f1 05       	cpc	r31, r1
     1b2:	10 f5       	brcc	.+68     	; 0x1f8 <KeyPad_u8AdjustKeyNumber_4x4+0x50>
     1b4:	e6 5d       	subi	r30, 0xD6	; 214
     1b6:	ff 4f       	sbci	r31, 0xFF	; 255
     1b8:	0c 94 8a 0a 	jmp	0x1514	; 0x1514 <__tablejump2__>
	{
		case 1: return '1';
				break;
		case 2: return '2';
     1bc:	82 e3       	ldi	r24, 0x32	; 50
     1be:	08 95       	ret
				break;
		case 3: return '3';
     1c0:	83 e3       	ldi	r24, 0x33	; 51
     1c2:	08 95       	ret
				break;
		case 4: return '-'; // ASCII Code of %
     1c4:	8d e2       	ldi	r24, 0x2D	; 45
     1c6:	08 95       	ret
				break;
		case 5: return '4';
     1c8:	84 e3       	ldi	r24, 0x34	; 52
     1ca:	08 95       	ret
				break;
		case 6: return '5';
     1cc:	85 e3       	ldi	r24, 0x35	; 53
     1ce:	08 95       	ret
				break;
		case 7: return '6';
     1d0:	86 e3       	ldi	r24, 0x36	; 54
     1d2:	08 95       	ret
				break;
		case 8: return '*'; /* ASCII Code of '*' */
     1d4:	8a e2       	ldi	r24, 0x2A	; 42
     1d6:	08 95       	ret
				break;
		case 9: return '7';
     1d8:	87 e3       	ldi	r24, 0x37	; 55
     1da:	08 95       	ret
				break;
		case 10: return '8';
     1dc:	88 e3       	ldi	r24, 0x38	; 56
     1de:	08 95       	ret
				break;
		case 11: return '9';
     1e0:	89 e3       	ldi	r24, 0x39	; 57
     1e2:	08 95       	ret
				break;
		case 12: return '/'; /* ASCII Code of '-' */
     1e4:	8f e2       	ldi	r24, 0x2F	; 47
     1e6:	08 95       	ret
				break;
		case 13: return 'C';  /* ASCII of Enter */
     1e8:	83 e4       	ldi	r24, 0x43	; 67
     1ea:	08 95       	ret
				break;
		case 14: return '0';
     1ec:	80 e3       	ldi	r24, 0x30	; 48
     1ee:	08 95       	ret
				break;
		case 15: return '='; /* ASCII Code of '=' */
     1f0:	8d e3       	ldi	r24, 0x3D	; 61
     1f2:	08 95       	ret
				break;
		case 16: return '+'; /* ASCII Code of '+' */
     1f4:	8b e2       	ldi	r24, 0x2B	; 43
     1f6:	08 95       	ret
				break;
		default: return NO_KEY_PRESSED;
     1f8:	8f ef       	ldi	r24, 0xFF	; 255
     1fa:	08 95       	ret

u8 KeyPad_u8AdjustKeyNumber_4x4(u8 button_number)
{
    switch(button_number)
	{
		case 1: return '1';
     1fc:	81 e3       	ldi	r24, 0x31	; 49
				break;
		default: return NO_KEY_PRESSED;
	}


}
     1fe:	08 95       	ret

00000200 <KeyPad_u8GetPressedKey>:
#include "KeyPad_int.h"



u8 KeyPad_u8GetPressedKey(void)
{
     200:	cf 92       	push	r12
     202:	df 92       	push	r13
     204:	ff 92       	push	r15
     206:	0f 93       	push	r16
     208:	1f 93       	push	r17
     20a:	cf 93       	push	r28
     20c:	df 93       	push	r29
     20e:	00 e0       	ldi	r16, 0x00	; 0
     210:	10 e0       	ldi	r17, 0x00	; 0
        /*
         * Each time only one of the column pins will be output and
         * the rest will be input pins including the row pins
         */

        DIO_voidSetPortDir(KEYPAD_PORT, (0b00010000<<col));
     212:	68 94       	set
     214:	cc 24       	eor	r12, r12
     216:	c4 f8       	bld	r12, 4
     218:	d1 2c       	mov	r13, r1
     21a:	f0 2e       	mov	r15, r16
     21c:	e6 01       	movw	r28, r12
     21e:	00 2e       	mov	r0, r16
     220:	02 c0       	rjmp	.+4      	; 0x226 <KeyPad_u8GetPressedKey+0x26>
     222:	cc 0f       	add	r28, r28
     224:	dd 1f       	adc	r29, r29
     226:	0a 94       	dec	r0
     228:	e2 f7       	brpl	.-8      	; 0x222 <KeyPad_u8GetPressedKey+0x22>
     22a:	6c 2f       	mov	r22, r28
     22c:	82 e0       	ldi	r24, 0x02	; 2
     22e:	0e 94 5f 00 	call	0xbe	; 0xbe <DIO_voidSetPortDir>

        /*
         * clear the output pin column and enable the internal
         * pull up resistors for the other pins
         */
        DIO_voidSetPort(KEYPAD_PORT, (~(0b00010000<<col)));
     232:	6c 2f       	mov	r22, r28
     234:	60 95       	com	r22
     236:	82 e0       	ldi	r24, 0x02	; 2
     238:	0e 94 6f 00 	call	0xde	; 0xde <DIO_voidSetPort>

        for(row=0; row<N_row; row++) /* loop for rows */
     23c:	c0 e0       	ldi	r28, 0x00	; 0
        {
            if(DIO_u8GetPinInPort(KEYPAD_PORT, row) == 0) /* if the switch is pressed in this row */
     23e:	6c 2f       	mov	r22, r28
     240:	82 e0       	ldi	r24, 0x02	; 2
     242:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_u8GetPinInPort>
     246:	81 11       	cpse	r24, r1
     248:	08 c0       	rjmp	.+16     	; 0x25a <KeyPad_u8GetPressedKey+0x5a>
            {
                #if (N_col == 3)
                    return KeyPad_u8AdjustKeyNumber_4x3((row*N_col)+col+1);
                #elif (N_col == 4)
                    return KeyPad_u8AdjustKeyNumber_4x4((row*N_col)+col+1);
     24a:	cc 0f       	add	r28, r28
     24c:	cc 0f       	add	r28, r28
     24e:	81 e0       	ldi	r24, 0x01	; 1
     250:	8f 0d       	add	r24, r15
     252:	8c 0f       	add	r24, r28
     254:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <KeyPad_u8AdjustKeyNumber_4x4>
     258:	09 c0       	rjmp	.+18     	; 0x26c <KeyPad_u8GetPressedKey+0x6c>
         * clear the output pin column and enable the internal
         * pull up resistors for the other pins
         */
        DIO_voidSetPort(KEYPAD_PORT, (~(0b00010000<<col)));

        for(row=0; row<N_row; row++) /* loop for rows */
     25a:	cf 5f       	subi	r28, 0xFF	; 255
     25c:	c4 30       	cpi	r28, 0x04	; 4
     25e:	79 f7       	brne	.-34     	; 0x23e <KeyPad_u8GetPressedKey+0x3e>
     260:	0f 5f       	subi	r16, 0xFF	; 255
     262:	1f 4f       	sbci	r17, 0xFF	; 255

u8 KeyPad_u8GetPressedKey(void)
{
    u8 col,row;

    for(col=0; col<=N_col; col++) /* loop for columns */
     264:	05 30       	cpi	r16, 0x05	; 5
     266:	11 05       	cpc	r17, r1
     268:	c1 f6       	brne	.-80     	; 0x21a <KeyPad_u8GetPressedKey+0x1a>
            }

        }
    }

    return NO_KEY_PRESSED;
     26a:	8f ef       	ldi	r24, 0xFF	; 255
}
     26c:	df 91       	pop	r29
     26e:	cf 91       	pop	r28
     270:	1f 91       	pop	r17
     272:	0f 91       	pop	r16
     274:	ff 90       	pop	r15
     276:	df 90       	pop	r13
     278:	cf 90       	pop	r12
     27a:	08 95       	ret

0000027c <enableTrigger>:
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{

	CLR_BIT(PORTB,2);
     27c:	c2 98       	cbi	0x18, 2	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     27e:	89 ef       	ldi	r24, 0xF9	; 249
     280:	90 e0       	ldi	r25, 0x00	; 0
     282:	01 97       	sbiw	r24, 0x01	; 1
     284:	f1 f7       	brne	.-4      	; 0x282 <enableTrigger+0x6>
     286:	00 c0       	rjmp	.+0      	; 0x288 <enableTrigger+0xc>
     288:	00 00       	nop
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
     28a:	c2 9a       	sbi	0x18, 2	; 24
     28c:	8b ed       	ldi	r24, 0xDB	; 219
     28e:	95 e0       	ldi	r25, 0x05	; 5
     290:	01 97       	sbiw	r24, 0x01	; 1
     292:	f1 f7       	brne	.-4      	; 0x290 <enableTrigger+0x14>
     294:	00 c0       	rjmp	.+0      	; 0x296 <enableTrigger+0x1a>
     296:	00 00       	nop
     298:	08 95       	ret

0000029a <lcd_sendCommand>:
		
}


void lcd_sendCommand(unsigned char cmd)
{
     29a:	cf 93       	push	r28
     29c:	c8 2f       	mov	r28, r24
	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);

	CLR_BIT(PORTB,0); // to enable command mode 
     29e:	c0 98       	cbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // write signal to lcd 
     2a0:	c1 98       	cbi	0x18, 1	; 24

	PORTB &=0x0f;
     2a2:	88 b3       	in	r24, 0x18	; 24
     2a4:	8f 70       	andi	r24, 0x0F	; 15
     2a6:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble command  
     2a8:	88 b3       	in	r24, 0x18	; 24
     2aa:	9c 2f       	mov	r25, r28
     2ac:	90 7f       	andi	r25, 0xF0	; 240
     2ae:	89 2b       	or	r24, r25
     2b0:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     2b2:	0e 94 3e 01 	call	0x27c	; 0x27c <enableTrigger>

	PORTB &=0x0f;
     2b6:	88 b3       	in	r24, 0x18	; 24
     2b8:	8f 70       	andi	r24, 0x0F	; 15
     2ba:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble command 
     2bc:	88 b3       	in	r24, 0x18	; 24
     2be:	c2 95       	swap	r28
     2c0:	c0 7f       	andi	r28, 0xF0	; 240
     2c2:	c8 2b       	or	r28, r24
     2c4:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
     2c6:	0e 94 3e 01 	call	0x27c	; 0x27c <enableTrigger>

}
     2ca:	cf 91       	pop	r28
     2cc:	08 95       	ret

000002ce <lcd_init>:
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{

	DDRB=0xff; // init port B as O/P port 
     2ce:	8f ef       	ldi	r24, 0xFF	; 255
     2d0:	87 bb       	out	0x17, r24	; 23
	PORTB=0x04; // activate LCD enable 
     2d2:	84 e0       	ldi	r24, 0x04	; 4
     2d4:	88 bb       	out	0x18, r24	; 24

	lcd_sendCommand(0x33); // 4-bit mode 
     2d6:	83 e3       	ldi	r24, 0x33	; 51
     2d8:	0e 94 4d 01 	call	0x29a	; 0x29a <lcd_sendCommand>
	lcd_sendCommand (0x32);
     2dc:	82 e3       	ldi	r24, 0x32	; 50
     2de:	0e 94 4d 01 	call	0x29a	; 0x29a <lcd_sendCommand>
	lcd_sendCommand (0x28);
     2e2:	88 e2       	ldi	r24, 0x28	; 40
     2e4:	0e 94 4d 01 	call	0x29a	; 0x29a <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
     2e8:	8c e0       	ldi	r24, 0x0C	; 12
     2ea:	0e 94 4d 01 	call	0x29a	; 0x29a <lcd_sendCommand>
     2ee:	08 95       	ret

000002f0 <lcd_displayChar>:
	enableTrigger();

}

void lcd_displayChar (unsigned char data)
{
     2f0:	cf 93       	push	r28
     2f2:	c8 2f       	mov	r28, r24

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
     2f4:	c0 9a       	sbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // activate lcd write 
     2f6:	c1 98       	cbi	0x18, 1	; 24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
     2f8:	88 b3       	in	r24, 0x18	; 24
     2fa:	8f 70       	andi	r24, 0x0F	; 15
     2fc:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble data  
     2fe:	88 b3       	in	r24, 0x18	; 24
     300:	9c 2f       	mov	r25, r28
     302:	90 7f       	andi	r25, 0xF0	; 240
     304:	89 2b       	or	r24, r25
     306:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     308:	0e 94 3e 01 	call	0x27c	; 0x27c <enableTrigger>
	
	PORTB &=0x0f;
     30c:	88 b3       	in	r24, 0x18	; 24
     30e:	8f 70       	andi	r24, 0x0F	; 15
     310:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble data 
     312:	88 b3       	in	r24, 0x18	; 24
     314:	c2 95       	swap	r28
     316:	c0 7f       	andi	r28, 0xF0	; 240
     318:	c8 2b       	or	r28, r24
     31a:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
     31c:	0e 94 3e 01 	call	0x27c	; 0x27c <enableTrigger>
	

}
     320:	cf 91       	pop	r28
     322:	08 95       	ret

00000324 <lcd_gotoxy>:

void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
	 
	switch(y)
     324:	81 30       	cpi	r24, 0x01	; 1
     326:	49 f0       	breq	.+18     	; 0x33a <lcd_gotoxy+0x16>
     328:	28 f0       	brcs	.+10     	; 0x334 <lcd_gotoxy+0x10>
     32a:	82 30       	cpi	r24, 0x02	; 2
     32c:	49 f0       	breq	.+18     	; 0x340 <lcd_gotoxy+0x1c>
     32e:	83 30       	cpi	r24, 0x03	; 3
     330:	51 f0       	breq	.+20     	; 0x346 <lcd_gotoxy+0x22>
     332:	0c c0       	rjmp	.+24     	; 0x34c <lcd_gotoxy+0x28>
	{
		case 0:

			position=position+x;
     334:	80 e8       	ldi	r24, 0x80	; 128
     336:	86 0f       	add	r24, r22
					
		break;
     338:	0a c0       	rjmp	.+20     	; 0x34e <lcd_gotoxy+0x2a>

		case 1:

			position=0xc0;
			position=position+x;
     33a:	80 ec       	ldi	r24, 0xC0	; 192
     33c:	86 0f       	add	r24, r22

		break;
     33e:	07 c0       	rjmp	.+14     	; 0x34e <lcd_gotoxy+0x2a>

		case 2:

			position=position+x;
     340:	80 e8       	ldi	r24, 0x80	; 128
     342:	86 0f       	add	r24, r22

		break;
     344:	04 c0       	rjmp	.+8      	; 0x34e <lcd_gotoxy+0x2a>

		case 3:
			position=position+x;
     346:	80 e8       	ldi	r24, 0x80	; 128
     348:	86 0f       	add	r24, r22
		break;
     34a:	01 c0       	rjmp	.+2      	; 0x34e <lcd_gotoxy+0x2a>
}


void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
     34c:	80 e8       	ldi	r24, 0x80	; 128
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
     34e:	0e 94 4d 01 	call	0x29a	; 0x29a <lcd_sendCommand>
     352:	08 95       	ret

00000354 <lcd_clrScreen>:


void lcd_clrScreen(void)
{

	lcd_sendCommand(0x01);
     354:	81 e0       	ldi	r24, 0x01	; 1
     356:	0e 94 4d 01 	call	0x29a	; 0x29a <lcd_sendCommand>
     35a:	08 95       	ret

0000035c <lcd_dispString>:

}


void lcd_dispString(char * ptr)
{
     35c:	cf 93       	push	r28
     35e:	df 93       	push	r29
     360:	ec 01       	movw	r28, r24

	while(* ptr!= '\0')
     362:	88 81       	ld	r24, Y
     364:	88 23       	and	r24, r24
     366:	31 f0       	breq	.+12     	; 0x374 <lcd_dispString+0x18>
     368:	21 96       	adiw	r28, 0x01	; 1
	{
		lcd_displayChar(* ptr);
     36a:	0e 94 78 01 	call	0x2f0	; 0x2f0 <lcd_displayChar>


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
     36e:	89 91       	ld	r24, Y+
     370:	81 11       	cpse	r24, r1
     372:	fb cf       	rjmp	.-10     	; 0x36a <lcd_dispString+0xe>
	
	}



}
     374:	df 91       	pop	r29
     376:	cf 91       	pop	r28
     378:	08 95       	ret

0000037a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     37a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     37c:	03 96       	adiw	r24, 0x03	; 3
     37e:	92 83       	std	Z+2, r25	; 0x02
     380:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     382:	2f ef       	ldi	r18, 0xFF	; 255
     384:	3f ef       	ldi	r19, 0xFF	; 255
     386:	34 83       	std	Z+4, r19	; 0x04
     388:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     38a:	96 83       	std	Z+6, r25	; 0x06
     38c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     38e:	90 87       	std	Z+8, r25	; 0x08
     390:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     392:	10 82       	st	Z, r1
     394:	08 95       	ret

00000396 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     396:	fc 01       	movw	r30, r24
     398:	11 86       	std	Z+9, r1	; 0x09
     39a:	10 86       	std	Z+8, r1	; 0x08
     39c:	08 95       	ret

0000039e <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     39e:	cf 93       	push	r28
     3a0:	df 93       	push	r29
     3a2:	fc 01       	movw	r30, r24
     3a4:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     3a6:	21 81       	ldd	r18, Z+1	; 0x01
     3a8:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     3aa:	e9 01       	movw	r28, r18
     3ac:	8a 81       	ldd	r24, Y+2	; 0x02
     3ae:	9b 81       	ldd	r25, Y+3	; 0x03
     3b0:	13 96       	adiw	r26, 0x03	; 3
     3b2:	9c 93       	st	X, r25
     3b4:	8e 93       	st	-X, r24
     3b6:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     3b8:	81 81       	ldd	r24, Z+1	; 0x01
     3ba:	92 81       	ldd	r25, Z+2	; 0x02
     3bc:	15 96       	adiw	r26, 0x05	; 5
     3be:	9c 93       	st	X, r25
     3c0:	8e 93       	st	-X, r24
     3c2:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     3c4:	8a 81       	ldd	r24, Y+2	; 0x02
     3c6:	9b 81       	ldd	r25, Y+3	; 0x03
     3c8:	ec 01       	movw	r28, r24
     3ca:	7d 83       	std	Y+5, r23	; 0x05
     3cc:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     3ce:	e9 01       	movw	r28, r18
     3d0:	7b 83       	std	Y+3, r23	; 0x03
     3d2:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     3d4:	72 83       	std	Z+2, r23	; 0x02
     3d6:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3d8:	19 96       	adiw	r26, 0x09	; 9
     3da:	fc 93       	st	X, r31
     3dc:	ee 93       	st	-X, r30
     3de:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     3e0:	80 81       	ld	r24, Z
     3e2:	8f 5f       	subi	r24, 0xFF	; 255
     3e4:	80 83       	st	Z, r24
}
     3e6:	df 91       	pop	r29
     3e8:	cf 91       	pop	r28
     3ea:	08 95       	ret

000003ec <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     3ec:	cf 93       	push	r28
     3ee:	df 93       	push	r29
     3f0:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     3f2:	48 81       	ld	r20, Y
     3f4:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     3f6:	4f 3f       	cpi	r20, 0xFF	; 255
     3f8:	2f ef       	ldi	r18, 0xFF	; 255
     3fa:	52 07       	cpc	r21, r18
     3fc:	31 f4       	brne	.+12     	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     3fe:	dc 01       	movw	r26, r24
     400:	17 96       	adiw	r26, 0x07	; 7
     402:	ed 91       	ld	r30, X+
     404:	fc 91       	ld	r31, X
     406:	18 97       	sbiw	r26, 0x08	; 8
     408:	17 c0       	rjmp	.+46     	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     40a:	fc 01       	movw	r30, r24
     40c:	33 96       	adiw	r30, 0x03	; 3
     40e:	dc 01       	movw	r26, r24
     410:	15 96       	adiw	r26, 0x05	; 5
     412:	2d 91       	ld	r18, X+
     414:	3c 91       	ld	r19, X
     416:	16 97       	sbiw	r26, 0x06	; 6
     418:	d9 01       	movw	r26, r18
     41a:	2d 91       	ld	r18, X+
     41c:	3c 91       	ld	r19, X
     41e:	42 17       	cp	r20, r18
     420:	53 07       	cpc	r21, r19
     422:	50 f0       	brcs	.+20     	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
     424:	02 80       	ldd	r0, Z+2	; 0x02
     426:	f3 81       	ldd	r31, Z+3	; 0x03
     428:	e0 2d       	mov	r30, r0
     42a:	a2 81       	ldd	r26, Z+2	; 0x02
     42c:	b3 81       	ldd	r27, Z+3	; 0x03
     42e:	2d 91       	ld	r18, X+
     430:	3c 91       	ld	r19, X
     432:	42 17       	cp	r20, r18
     434:	53 07       	cpc	r21, r19
     436:	b0 f7       	brcc	.-20     	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     438:	a2 81       	ldd	r26, Z+2	; 0x02
     43a:	b3 81       	ldd	r27, Z+3	; 0x03
     43c:	bb 83       	std	Y+3, r27	; 0x03
     43e:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     440:	15 96       	adiw	r26, 0x05	; 5
     442:	dc 93       	st	X, r29
     444:	ce 93       	st	-X, r28
     446:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     448:	fd 83       	std	Y+5, r31	; 0x05
     44a:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     44c:	d3 83       	std	Z+3, r29	; 0x03
     44e:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     450:	99 87       	std	Y+9, r25	; 0x09
     452:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     454:	fc 01       	movw	r30, r24
     456:	20 81       	ld	r18, Z
     458:	2f 5f       	subi	r18, 0xFF	; 255
     45a:	20 83       	st	Z, r18
}
     45c:	df 91       	pop	r29
     45e:	cf 91       	pop	r28
     460:	08 95       	ret

00000462 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     462:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     464:	a2 81       	ldd	r26, Z+2	; 0x02
     466:	b3 81       	ldd	r27, Z+3	; 0x03
     468:	84 81       	ldd	r24, Z+4	; 0x04
     46a:	95 81       	ldd	r25, Z+5	; 0x05
     46c:	15 96       	adiw	r26, 0x05	; 5
     46e:	9c 93       	st	X, r25
     470:	8e 93       	st	-X, r24
     472:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     474:	a4 81       	ldd	r26, Z+4	; 0x04
     476:	b5 81       	ldd	r27, Z+5	; 0x05
     478:	82 81       	ldd	r24, Z+2	; 0x02
     47a:	93 81       	ldd	r25, Z+3	; 0x03
     47c:	13 96       	adiw	r26, 0x03	; 3
     47e:	9c 93       	st	X, r25
     480:	8e 93       	st	-X, r24
     482:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     484:	a0 85       	ldd	r26, Z+8	; 0x08
     486:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     488:	11 96       	adiw	r26, 0x01	; 1
     48a:	8d 91       	ld	r24, X+
     48c:	9c 91       	ld	r25, X
     48e:	12 97       	sbiw	r26, 0x02	; 2
     490:	e8 17       	cp	r30, r24
     492:	f9 07       	cpc	r31, r25
     494:	31 f4       	brne	.+12     	; 0x4a2 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     496:	84 81       	ldd	r24, Z+4	; 0x04
     498:	95 81       	ldd	r25, Z+5	; 0x05
     49a:	12 96       	adiw	r26, 0x02	; 2
     49c:	9c 93       	st	X, r25
     49e:	8e 93       	st	-X, r24
     4a0:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     4a2:	11 86       	std	Z+9, r1	; 0x09
     4a4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     4a6:	8c 91       	ld	r24, X
     4a8:	81 50       	subi	r24, 0x01	; 1
     4aa:	8c 93       	st	X, r24
     4ac:	08 95       	ret

000004ae <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     4ae:	31 e1       	ldi	r19, 0x11	; 17
     4b0:	fc 01       	movw	r30, r24
     4b2:	30 83       	st	Z, r19
     4b4:	31 97       	sbiw	r30, 0x01	; 1
     4b6:	22 e2       	ldi	r18, 0x22	; 34
     4b8:	20 83       	st	Z, r18
     4ba:	31 97       	sbiw	r30, 0x01	; 1
     4bc:	a3 e3       	ldi	r26, 0x33	; 51
     4be:	a0 83       	st	Z, r26
     4c0:	31 97       	sbiw	r30, 0x01	; 1
     4c2:	60 83       	st	Z, r22
     4c4:	31 97       	sbiw	r30, 0x01	; 1
     4c6:	70 83       	st	Z, r23
     4c8:	31 97       	sbiw	r30, 0x01	; 1
     4ca:	10 82       	st	Z, r1
     4cc:	31 97       	sbiw	r30, 0x01	; 1
     4ce:	60 e8       	ldi	r22, 0x80	; 128
     4d0:	60 83       	st	Z, r22
     4d2:	31 97       	sbiw	r30, 0x01	; 1
     4d4:	10 82       	st	Z, r1
     4d6:	31 97       	sbiw	r30, 0x01	; 1
     4d8:	62 e0       	ldi	r22, 0x02	; 2
     4da:	60 83       	st	Z, r22
     4dc:	31 97       	sbiw	r30, 0x01	; 1
     4de:	63 e0       	ldi	r22, 0x03	; 3
     4e0:	60 83       	st	Z, r22
     4e2:	31 97       	sbiw	r30, 0x01	; 1
     4e4:	64 e0       	ldi	r22, 0x04	; 4
     4e6:	60 83       	st	Z, r22
     4e8:	31 97       	sbiw	r30, 0x01	; 1
     4ea:	65 e0       	ldi	r22, 0x05	; 5
     4ec:	60 83       	st	Z, r22
     4ee:	31 97       	sbiw	r30, 0x01	; 1
     4f0:	66 e0       	ldi	r22, 0x06	; 6
     4f2:	60 83       	st	Z, r22
     4f4:	31 97       	sbiw	r30, 0x01	; 1
     4f6:	67 e0       	ldi	r22, 0x07	; 7
     4f8:	60 83       	st	Z, r22
     4fa:	31 97       	sbiw	r30, 0x01	; 1
     4fc:	68 e0       	ldi	r22, 0x08	; 8
     4fe:	60 83       	st	Z, r22
     500:	31 97       	sbiw	r30, 0x01	; 1
     502:	69 e0       	ldi	r22, 0x09	; 9
     504:	60 83       	st	Z, r22
     506:	31 97       	sbiw	r30, 0x01	; 1
     508:	60 e1       	ldi	r22, 0x10	; 16
     50a:	60 83       	st	Z, r22
     50c:	31 97       	sbiw	r30, 0x01	; 1
     50e:	30 83       	st	Z, r19
     510:	31 97       	sbiw	r30, 0x01	; 1
     512:	32 e1       	ldi	r19, 0x12	; 18
     514:	30 83       	st	Z, r19
     516:	31 97       	sbiw	r30, 0x01	; 1
     518:	33 e1       	ldi	r19, 0x13	; 19
     51a:	30 83       	st	Z, r19
     51c:	31 97       	sbiw	r30, 0x01	; 1
     51e:	34 e1       	ldi	r19, 0x14	; 20
     520:	30 83       	st	Z, r19
     522:	31 97       	sbiw	r30, 0x01	; 1
     524:	35 e1       	ldi	r19, 0x15	; 21
     526:	30 83       	st	Z, r19
     528:	31 97       	sbiw	r30, 0x01	; 1
     52a:	36 e1       	ldi	r19, 0x16	; 22
     52c:	30 83       	st	Z, r19
     52e:	31 97       	sbiw	r30, 0x01	; 1
     530:	37 e1       	ldi	r19, 0x17	; 23
     532:	30 83       	st	Z, r19
     534:	31 97       	sbiw	r30, 0x01	; 1
     536:	38 e1       	ldi	r19, 0x18	; 24
     538:	30 83       	st	Z, r19
     53a:	31 97       	sbiw	r30, 0x01	; 1
     53c:	39 e1       	ldi	r19, 0x19	; 25
     53e:	30 83       	st	Z, r19
     540:	31 97       	sbiw	r30, 0x01	; 1
     542:	30 e2       	ldi	r19, 0x20	; 32
     544:	30 83       	st	Z, r19
     546:	31 97       	sbiw	r30, 0x01	; 1
     548:	31 e2       	ldi	r19, 0x21	; 33
     54a:	30 83       	st	Z, r19
     54c:	31 97       	sbiw	r30, 0x01	; 1
     54e:	20 83       	st	Z, r18
     550:	31 97       	sbiw	r30, 0x01	; 1
     552:	23 e2       	ldi	r18, 0x23	; 35
     554:	20 83       	st	Z, r18
     556:	31 97       	sbiw	r30, 0x01	; 1
     558:	40 83       	st	Z, r20
     55a:	31 97       	sbiw	r30, 0x01	; 1
     55c:	50 83       	st	Z, r21
     55e:	31 97       	sbiw	r30, 0x01	; 1
     560:	26 e2       	ldi	r18, 0x26	; 38
     562:	20 83       	st	Z, r18
     564:	31 97       	sbiw	r30, 0x01	; 1
     566:	27 e2       	ldi	r18, 0x27	; 39
     568:	20 83       	st	Z, r18
     56a:	31 97       	sbiw	r30, 0x01	; 1
     56c:	28 e2       	ldi	r18, 0x28	; 40
     56e:	20 83       	st	Z, r18
     570:	31 97       	sbiw	r30, 0x01	; 1
     572:	29 e2       	ldi	r18, 0x29	; 41
     574:	20 83       	st	Z, r18
     576:	31 97       	sbiw	r30, 0x01	; 1
     578:	20 e3       	ldi	r18, 0x30	; 48
     57a:	20 83       	st	Z, r18
     57c:	31 97       	sbiw	r30, 0x01	; 1
     57e:	21 e3       	ldi	r18, 0x31	; 49
     580:	20 83       	st	Z, r18
     582:	86 97       	sbiw	r24, 0x26	; 38
     584:	08 95       	ret

00000586 <xPortStartScheduler>:
     586:	1b bc       	out	0x2b, r1	; 43
     588:	8c e7       	ldi	r24, 0x7C	; 124
     58a:	8a bd       	out	0x2a, r24	; 42
     58c:	8b e0       	ldi	r24, 0x0B	; 11
     58e:	8e bd       	out	0x2e, r24	; 46
     590:	89 b7       	in	r24, 0x39	; 57
     592:	80 61       	ori	r24, 0x10	; 16
     594:	89 bf       	out	0x39, r24	; 57
     596:	a0 91 f2 06 	lds	r26, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     59a:	b0 91 f3 06 	lds	r27, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     59e:	cd 91       	ld	r28, X+
     5a0:	cd bf       	out	0x3d, r28	; 61
     5a2:	dd 91       	ld	r29, X+
     5a4:	de bf       	out	0x3e, r29	; 62
     5a6:	ff 91       	pop	r31
     5a8:	ef 91       	pop	r30
     5aa:	df 91       	pop	r29
     5ac:	cf 91       	pop	r28
     5ae:	bf 91       	pop	r27
     5b0:	af 91       	pop	r26
     5b2:	9f 91       	pop	r25
     5b4:	8f 91       	pop	r24
     5b6:	7f 91       	pop	r23
     5b8:	6f 91       	pop	r22
     5ba:	5f 91       	pop	r21
     5bc:	4f 91       	pop	r20
     5be:	3f 91       	pop	r19
     5c0:	2f 91       	pop	r18
     5c2:	1f 91       	pop	r17
     5c4:	0f 91       	pop	r16
     5c6:	ff 90       	pop	r15
     5c8:	ef 90       	pop	r14
     5ca:	df 90       	pop	r13
     5cc:	cf 90       	pop	r12
     5ce:	bf 90       	pop	r11
     5d0:	af 90       	pop	r10
     5d2:	9f 90       	pop	r9
     5d4:	8f 90       	pop	r8
     5d6:	7f 90       	pop	r7
     5d8:	6f 90       	pop	r6
     5da:	5f 90       	pop	r5
     5dc:	4f 90       	pop	r4
     5de:	3f 90       	pop	r3
     5e0:	2f 90       	pop	r2
     5e2:	1f 90       	pop	r1
     5e4:	0f 90       	pop	r0
     5e6:	0f be       	out	0x3f, r0	; 63
     5e8:	0f 90       	pop	r0
     5ea:	08 95       	ret
     5ec:	81 e0       	ldi	r24, 0x01	; 1
     5ee:	08 95       	ret

000005f0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     5f0:	0f 92       	push	r0
     5f2:	0f b6       	in	r0, 0x3f	; 63
     5f4:	f8 94       	cli
     5f6:	0f 92       	push	r0
     5f8:	1f 92       	push	r1
     5fa:	11 24       	eor	r1, r1
     5fc:	2f 92       	push	r2
     5fe:	3f 92       	push	r3
     600:	4f 92       	push	r4
     602:	5f 92       	push	r5
     604:	6f 92       	push	r6
     606:	7f 92       	push	r7
     608:	8f 92       	push	r8
     60a:	9f 92       	push	r9
     60c:	af 92       	push	r10
     60e:	bf 92       	push	r11
     610:	cf 92       	push	r12
     612:	df 92       	push	r13
     614:	ef 92       	push	r14
     616:	ff 92       	push	r15
     618:	0f 93       	push	r16
     61a:	1f 93       	push	r17
     61c:	2f 93       	push	r18
     61e:	3f 93       	push	r19
     620:	4f 93       	push	r20
     622:	5f 93       	push	r21
     624:	6f 93       	push	r22
     626:	7f 93       	push	r23
     628:	8f 93       	push	r24
     62a:	9f 93       	push	r25
     62c:	af 93       	push	r26
     62e:	bf 93       	push	r27
     630:	cf 93       	push	r28
     632:	df 93       	push	r29
     634:	ef 93       	push	r30
     636:	ff 93       	push	r31
     638:	a0 91 f2 06 	lds	r26, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     63c:	b0 91 f3 06 	lds	r27, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     640:	0d b6       	in	r0, 0x3d	; 61
     642:	0d 92       	st	X+, r0
     644:	0e b6       	in	r0, 0x3e	; 62
     646:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     648:	0e 94 0a 0a 	call	0x1414	; 0x1414 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     64c:	a0 91 f2 06 	lds	r26, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     650:	b0 91 f3 06 	lds	r27, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     654:	cd 91       	ld	r28, X+
     656:	cd bf       	out	0x3d, r28	; 61
     658:	dd 91       	ld	r29, X+
     65a:	de bf       	out	0x3e, r29	; 62
     65c:	ff 91       	pop	r31
     65e:	ef 91       	pop	r30
     660:	df 91       	pop	r29
     662:	cf 91       	pop	r28
     664:	bf 91       	pop	r27
     666:	af 91       	pop	r26
     668:	9f 91       	pop	r25
     66a:	8f 91       	pop	r24
     66c:	7f 91       	pop	r23
     66e:	6f 91       	pop	r22
     670:	5f 91       	pop	r21
     672:	4f 91       	pop	r20
     674:	3f 91       	pop	r19
     676:	2f 91       	pop	r18
     678:	1f 91       	pop	r17
     67a:	0f 91       	pop	r16
     67c:	ff 90       	pop	r15
     67e:	ef 90       	pop	r14
     680:	df 90       	pop	r13
     682:	cf 90       	pop	r12
     684:	bf 90       	pop	r11
     686:	af 90       	pop	r10
     688:	9f 90       	pop	r9
     68a:	8f 90       	pop	r8
     68c:	7f 90       	pop	r7
     68e:	6f 90       	pop	r6
     690:	5f 90       	pop	r5
     692:	4f 90       	pop	r4
     694:	3f 90       	pop	r3
     696:	2f 90       	pop	r2
     698:	1f 90       	pop	r1
     69a:	0f 90       	pop	r0
     69c:	0f be       	out	0x3f, r0	; 63
     69e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6a0:	08 95       	ret

000006a2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     6a2:	0f 92       	push	r0
     6a4:	0f b6       	in	r0, 0x3f	; 63
     6a6:	f8 94       	cli
     6a8:	0f 92       	push	r0
     6aa:	1f 92       	push	r1
     6ac:	11 24       	eor	r1, r1
     6ae:	2f 92       	push	r2
     6b0:	3f 92       	push	r3
     6b2:	4f 92       	push	r4
     6b4:	5f 92       	push	r5
     6b6:	6f 92       	push	r6
     6b8:	7f 92       	push	r7
     6ba:	8f 92       	push	r8
     6bc:	9f 92       	push	r9
     6be:	af 92       	push	r10
     6c0:	bf 92       	push	r11
     6c2:	cf 92       	push	r12
     6c4:	df 92       	push	r13
     6c6:	ef 92       	push	r14
     6c8:	ff 92       	push	r15
     6ca:	0f 93       	push	r16
     6cc:	1f 93       	push	r17
     6ce:	2f 93       	push	r18
     6d0:	3f 93       	push	r19
     6d2:	4f 93       	push	r20
     6d4:	5f 93       	push	r21
     6d6:	6f 93       	push	r22
     6d8:	7f 93       	push	r23
     6da:	8f 93       	push	r24
     6dc:	9f 93       	push	r25
     6de:	af 93       	push	r26
     6e0:	bf 93       	push	r27
     6e2:	cf 93       	push	r28
     6e4:	df 93       	push	r29
     6e6:	ef 93       	push	r30
     6e8:	ff 93       	push	r31
     6ea:	a0 91 f2 06 	lds	r26, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     6ee:	b0 91 f3 06 	lds	r27, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     6f2:	0d b6       	in	r0, 0x3d	; 61
     6f4:	0d 92       	st	X+, r0
     6f6:	0e b6       	in	r0, 0x3e	; 62
     6f8:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     6fa:	0e 94 46 08 	call	0x108c	; 0x108c <vTaskIncrementTick>
	vTaskSwitchContext();
     6fe:	0e 94 0a 0a 	call	0x1414	; 0x1414 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     702:	a0 91 f2 06 	lds	r26, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     706:	b0 91 f3 06 	lds	r27, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     70a:	cd 91       	ld	r28, X+
     70c:	cd bf       	out	0x3d, r28	; 61
     70e:	dd 91       	ld	r29, X+
     710:	de bf       	out	0x3e, r29	; 62
     712:	ff 91       	pop	r31
     714:	ef 91       	pop	r30
     716:	df 91       	pop	r29
     718:	cf 91       	pop	r28
     71a:	bf 91       	pop	r27
     71c:	af 91       	pop	r26
     71e:	9f 91       	pop	r25
     720:	8f 91       	pop	r24
     722:	7f 91       	pop	r23
     724:	6f 91       	pop	r22
     726:	5f 91       	pop	r21
     728:	4f 91       	pop	r20
     72a:	3f 91       	pop	r19
     72c:	2f 91       	pop	r18
     72e:	1f 91       	pop	r17
     730:	0f 91       	pop	r16
     732:	ff 90       	pop	r15
     734:	ef 90       	pop	r14
     736:	df 90       	pop	r13
     738:	cf 90       	pop	r12
     73a:	bf 90       	pop	r11
     73c:	af 90       	pop	r10
     73e:	9f 90       	pop	r9
     740:	8f 90       	pop	r8
     742:	7f 90       	pop	r7
     744:	6f 90       	pop	r6
     746:	5f 90       	pop	r5
     748:	4f 90       	pop	r4
     74a:	3f 90       	pop	r3
     74c:	2f 90       	pop	r2
     74e:	1f 90       	pop	r1
     750:	0f 90       	pop	r0
     752:	0f be       	out	0x3f, r0	; 63
     754:	0f 90       	pop	r0

	asm volatile ( "ret" );
     756:	08 95       	ret

00000758 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     758:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     75c:	18 95       	reti

0000075e <PWM0_Init>:
void PWM0_Init(void)
{
	//  Wave generator (WGM01:0)
#if PWM_Mode == Fast_Mode

	SETBIT(TCCR2,3);
     75e:	85 b5       	in	r24, 0x25	; 37
     760:	88 60       	ori	r24, 0x08	; 8
     762:	85 bd       	out	0x25, r24	; 37
	SETBIT(TCCR2,6);
     764:	85 b5       	in	r24, 0x25	; 37
     766:	80 64       	ori	r24, 0x40	; 64
     768:	85 bd       	out	0x25, r24	; 37

#endif
	//  Compare match O/P COM01:0:
#if PWM_Output_Mode	==	Non_Invert

	CLRBIT(TCCR2,4);
     76a:	85 b5       	in	r24, 0x25	; 37
     76c:	8f 7e       	andi	r24, 0xEF	; 239
     76e:	85 bd       	out	0x25, r24	; 37
	SETBIT(TCCR2,5);
     770:	85 b5       	in	r24, 0x25	; 37
     772:	80 62       	ori	r24, 0x20	; 32
     774:	85 bd       	out	0x25, r24	; 37
#if PWM_Freq	==	_61_Hz
	SETBIT(TCCR2,0);
	CLRBIT(TCCR2,1);
	SETBIT(TCCR2,2);
#elif PWM_Freq	==	_244_Hz
	CLRBIT(TCCR2,0);
     776:	85 b5       	in	r24, 0x25	; 37
     778:	8e 7f       	andi	r24, 0xFE	; 254
     77a:	85 bd       	out	0x25, r24	; 37
	SETBIT(TCCR2,1);
     77c:	85 b5       	in	r24, 0x25	; 37
     77e:	82 60       	ori	r24, 0x02	; 2
     780:	85 bd       	out	0x25, r24	; 37
	SETBIT(TCCR2,2);
     782:	85 b5       	in	r24, 0x25	; 37
     784:	84 60       	ori	r24, 0x04	; 4
     786:	85 bd       	out	0x25, r24	; 37
     788:	08 95       	ret

0000078a <PWM0_SetDutyCycle>:
}


void PWM0_SetDutyCycle(u8 DC)
{
if (DC>-1 && DC<101)
     78a:	85 36       	cpi	r24, 0x65	; 101
     78c:	50 f4       	brcc	.+20     	; 0x7a2 <PWM0_SetDutyCycle+0x18>
{
	OCR2= (u8) ((DC*255)/100);
     78e:	2f ef       	ldi	r18, 0xFF	; 255
     790:	82 9f       	mul	r24, r18
     792:	c0 01       	movw	r24, r0
     794:	11 24       	eor	r1, r1
     796:	64 e6       	ldi	r22, 0x64	; 100
     798:	70 e0       	ldi	r23, 0x00	; 0
     79a:	0e 94 76 0a 	call	0x14ec	; 0x14ec <__divmodhi4>
     79e:	63 bd       	out	0x23, r22	; 35
     7a0:	08 95       	ret
}
else
{
	OCR2=0;
     7a2:	13 bc       	out	0x23, r1	; 35
     7a4:	08 95       	ret

000007a6 <PWM0_Stop>:
}

}

void PWM0_Stop(){
		CLRBIT(TCCR2,0);
     7a6:	85 b5       	in	r24, 0x25	; 37
     7a8:	8e 7f       	andi	r24, 0xFE	; 254
     7aa:	85 bd       	out	0x25, r24	; 37
		CLRBIT(TCCR2,1);
     7ac:	85 b5       	in	r24, 0x25	; 37
     7ae:	8d 7f       	andi	r24, 0xFD	; 253
     7b0:	85 bd       	out	0x25, r24	; 37
		CLRBIT(TCCR2,2);
     7b2:	85 b5       	in	r24, 0x25	; 37
     7b4:	8b 7f       	andi	r24, 0xFB	; 251
     7b6:	85 bd       	out	0x25, r24	; 37
     7b8:	08 95       	ret

000007ba <task1_code>:
}



 void task1_code(void*pvParameters)
{
     7ba:	cf 93       	push	r28
     7bc:	df 93       	push	r29
     7be:	00 d0       	rcall	.+0      	; 0x7c0 <task1_code+0x6>
     7c0:	cd b7       	in	r28, 0x3d	; 61
     7c2:	de b7       	in	r29, 0x3e	; 62
    static char x = 0;
    static char flag = 0;
	static char counter = 0;
    portTickType count = xTaskGetTickCount();
     7c4:	0e 94 3c 08 	call	0x1078	; 0x1078 <xTaskGetTickCount>
     7c8:	9a 83       	std	Y+2, r25	; 0x02
     7ca:	89 83       	std	Y+1, r24	; 0x01
    while(1)
	{   
    vTaskDelayUntil(&count,50);
     7cc:	62 e3       	ldi	r22, 0x32	; 50
     7ce:	70 e0       	ldi	r23, 0x00	; 0
     7d0:	ce 01       	movw	r24, r28
     7d2:	01 96       	adiw	r24, 0x01	; 1
     7d4:	0e 94 90 09 	call	0x1320	; 0x1320 <vTaskDelayUntil>
    if (x >= 0 && x<= 10 && flag == 0)
     7d8:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <x.1982>
     7dc:	8b 30       	cpi	r24, 0x0B	; 11
     7de:	d0 f4       	brcc	.+52     	; 0x814 <task1_code+0x5a>
     7e0:	80 91 86 06 	lds	r24, 0x0686	; 0x800686 <flag.1983>
     7e4:	81 11       	cpse	r24, r1
     7e6:	16 c0       	rjmp	.+44     	; 0x814 <task1_code+0x5a>
    {
	    lcd_clrScreen();
     7e8:	0e 94 aa 01 	call	0x354	; 0x354 <lcd_clrScreen>
	    lcd_gotoxy(0,x);
     7ec:	60 91 87 06 	lds	r22, 0x0687	; 0x800687 <x.1982>
     7f0:	80 e0       	ldi	r24, 0x00	; 0
     7f2:	0e 94 92 01 	call	0x324	; 0x324 <lcd_gotoxy>
	    lcd_dispString("welcome");
     7f6:	84 e6       	ldi	r24, 0x64	; 100
     7f8:	90 e0       	ldi	r25, 0x00	; 0
     7fa:	0e 94 ae 01 	call	0x35c	; 0x35c <lcd_dispString>
	    x++;
     7fe:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <x.1982>
     802:	8f 5f       	subi	r24, 0xFF	; 255
     804:	80 93 87 06 	sts	0x0687, r24	; 0x800687 <x.1982>
	    if (x>10) flag = 1;
     808:	8b 30       	cpi	r24, 0x0B	; 11
     80a:	00 f3       	brcs	.-64     	; 0x7cc <task1_code+0x12>
     80c:	81 e0       	ldi	r24, 0x01	; 1
     80e:	80 93 86 06 	sts	0x0686, r24	; 0x800686 <flag.1983>
     812:	dc cf       	rjmp	.-72     	; 0x7cc <task1_code+0x12>
    }
    else if (flag == 1)
     814:	80 91 86 06 	lds	r24, 0x0686	; 0x800686 <flag.1983>
     818:	81 30       	cpi	r24, 0x01	; 1
     81a:	c1 f6       	brne	.-80     	; 0x7cc <task1_code+0x12>
    {
	    lcd_clrScreen();
     81c:	0e 94 aa 01 	call	0x354	; 0x354 <lcd_clrScreen>
	    lcd_gotoxy(0,x);
     820:	60 91 87 06 	lds	r22, 0x0687	; 0x800687 <x.1982>
     824:	80 e0       	ldi	r24, 0x00	; 0
     826:	0e 94 92 01 	call	0x324	; 0x324 <lcd_gotoxy>
	    lcd_dispString("welcome");
     82a:	84 e6       	ldi	r24, 0x64	; 100
     82c:	90 e0       	ldi	r25, 0x00	; 0
     82e:	0e 94 ae 01 	call	0x35c	; 0x35c <lcd_dispString>
	    x--;
     832:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <x.1982>
     836:	81 50       	subi	r24, 0x01	; 1
     838:	80 93 87 06 	sts	0x0687, r24	; 0x800687 <x.1982>
	    if (x == 0) 
     83c:	81 11       	cpse	r24, r1
     83e:	c6 cf       	rjmp	.-116    	; 0x7cc <task1_code+0x12>
		{
			flag = 0;
     840:	10 92 86 06 	sts	0x0686, r1	; 0x800686 <flag.1983>
			counter++;
     844:	80 91 85 06 	lds	r24, 0x0685	; 0x800685 <counter.1984>
     848:	8f 5f       	subi	r24, 0xFF	; 255
     84a:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <counter.1984>
		if (counter == 3)
     84e:	83 30       	cpi	r24, 0x03	; 3
     850:	09 f0       	breq	.+2      	; 0x854 <task1_code+0x9a>
     852:	bc cf       	rjmp	.-136    	; 0x7cc <task1_code+0x12>
		{	
		lcd_clrScreen();
     854:	0e 94 aa 01 	call	0x354	; 0x354 <lcd_clrScreen>
		xTaskCreate(task2_code,NULL,85,NULL,TASK2_PRIORITY,&task2);
     858:	a1 2c       	mov	r10, r1
     85a:	b1 2c       	mov	r11, r1
     85c:	c1 2c       	mov	r12, r1
     85e:	d1 2c       	mov	r13, r1
     860:	0f 2e       	mov	r0, r31
     862:	f8 ef       	ldi	r31, 0xF8	; 248
     864:	ef 2e       	mov	r14, r31
     866:	f6 e0       	ldi	r31, 0x06	; 6
     868:	ff 2e       	mov	r15, r31
     86a:	f0 2d       	mov	r31, r0
     86c:	01 e0       	ldi	r16, 0x01	; 1
     86e:	20 e0       	ldi	r18, 0x00	; 0
     870:	30 e0       	ldi	r19, 0x00	; 0
     872:	45 e5       	ldi	r20, 0x55	; 85
     874:	50 e0       	ldi	r21, 0x00	; 0
     876:	60 e0       	ldi	r22, 0x00	; 0
     878:	70 e0       	ldi	r23, 0x00	; 0
     87a:	89 e5       	ldi	r24, 0x59	; 89
     87c:	94 e0       	ldi	r25, 0x04	; 4
     87e:	0e 94 b4 06 	call	0xd68	; 0xd68 <xTaskGenericCreate>
		xTaskCreate(keycheck_code,NULL,85,NULL,4,&keycheck);
     882:	0f 2e       	mov	r0, r31
     884:	f4 ef       	ldi	r31, 0xF4	; 244
     886:	ef 2e       	mov	r14, r31
     888:	f6 e0       	ldi	r31, 0x06	; 6
     88a:	ff 2e       	mov	r15, r31
     88c:	f0 2d       	mov	r31, r0
     88e:	04 e0       	ldi	r16, 0x04	; 4
     890:	20 e0       	ldi	r18, 0x00	; 0
     892:	30 e0       	ldi	r19, 0x00	; 0
     894:	45 e5       	ldi	r20, 0x55	; 85
     896:	50 e0       	ldi	r21, 0x00	; 0
     898:	60 e0       	ldi	r22, 0x00	; 0
     89a:	70 e0       	ldi	r23, 0x00	; 0
     89c:	8e ea       	ldi	r24, 0xAE	; 174
     89e:	94 e0       	ldi	r25, 0x04	; 4
     8a0:	0e 94 b4 06 	call	0xd68	; 0xd68 <xTaskGenericCreate>
		vTaskDelete(welcome);
     8a4:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <welcome>
     8a8:	90 91 fd 06 	lds	r25, 0x06FD	; 0x8006fd <welcome+0x1>
     8ac:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskDelete>
     8b0:	8d cf       	rjmp	.-230    	; 0x7cc <task1_code+0x12>

000008b2 <task2_code>:
    }
   } 
}

  void task2_code(void*pvParamter)
   {
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	00 d0       	rcall	.+0      	; 0x8b8 <task2_code+0x6>
     8b8:	cd b7       	in	r28, 0x3d	; 61
     8ba:	de b7       	in	r29, 0x3e	; 62
		static char flag = 0,counter=0;
		portTickType count = xTaskGetTickCount(); 
     8bc:	0e 94 3c 08 	call	0x1078	; 0x1078 <xTaskGetTickCount>
     8c0:	9a 83       	std	Y+2, r25	; 0x02
     8c2:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		vTaskDelayUntil(&count,250);
     8c4:	6a ef       	ldi	r22, 0xFA	; 250
     8c6:	70 e0       	ldi	r23, 0x00	; 0
     8c8:	ce 01       	movw	r24, r28
     8ca:	01 96       	adiw	r24, 0x01	; 1
     8cc:	0e 94 90 09 	call	0x1320	; 0x1320 <vTaskDelayUntil>
		if(counter == 40){
     8d0:	80 91 84 06 	lds	r24, 0x0684	; 0x800684 <counter.1991>
     8d4:	88 32       	cpi	r24, 0x28	; 40
     8d6:	d9 f4       	brne	.+54     	; 0x90e <task2_code+0x5c>
			xTaskCreate(LED_code,NULL,85,NULL,2,&LED);
     8d8:	a1 2c       	mov	r10, r1
     8da:	b1 2c       	mov	r11, r1
     8dc:	c1 2c       	mov	r12, r1
     8de:	d1 2c       	mov	r13, r1
     8e0:	0f 2e       	mov	r0, r31
     8e2:	fa ef       	ldi	r31, 0xFA	; 250
     8e4:	ef 2e       	mov	r14, r31
     8e6:	f6 e0       	ldi	r31, 0x06	; 6
     8e8:	ff 2e       	mov	r15, r31
     8ea:	f0 2d       	mov	r31, r0
     8ec:	02 e0       	ldi	r16, 0x02	; 2
     8ee:	20 e0       	ldi	r18, 0x00	; 0
     8f0:	30 e0       	ldi	r19, 0x00	; 0
     8f2:	45 e5       	ldi	r20, 0x55	; 85
     8f4:	50 e0       	ldi	r21, 0x00	; 0
     8f6:	60 e0       	ldi	r22, 0x00	; 0
     8f8:	70 e0       	ldi	r23, 0x00	; 0
     8fa:	83 ee       	ldi	r24, 0xE3	; 227
     8fc:	94 e0       	ldi	r25, 0x04	; 4
     8fe:	0e 94 b4 06 	call	0xd68	; 0xd68 <xTaskGenericCreate>
			vTaskDelete(task2);
     902:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <task2>
     906:	90 91 f9 06 	lds	r25, 0x06F9	; 0x8006f9 <task2+0x1>
     90a:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskDelete>
		}
		if ( flag < 2)
     90e:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <flag.1990>
     912:	82 30       	cpi	r24, 0x02	; 2
     914:	a8 f4       	brcc	.+42     	; 0x940 <task2_code+0x8e>
		{
			lcd_gotoxy(0,0);
     916:	60 e0       	ldi	r22, 0x00	; 0
     918:	80 e0       	ldi	r24, 0x00	; 0
     91a:	0e 94 92 01 	call	0x324	; 0x324 <lcd_gotoxy>
			lcd_dispString("Press any Key to");
     91e:	8c e6       	ldi	r24, 0x6C	; 108
     920:	90 e0       	ldi	r25, 0x00	; 0
     922:	0e 94 ae 01 	call	0x35c	; 0x35c <lcd_dispString>
			lcd_gotoxy(1,1);
     926:	61 e0       	ldi	r22, 0x01	; 1
     928:	81 e0       	ldi	r24, 0x01	; 1
     92a:	0e 94 92 01 	call	0x324	; 0x324 <lcd_gotoxy>
			lcd_dispString("Continue");
     92e:	8d e7       	ldi	r24, 0x7D	; 125
     930:	90 e0       	ldi	r25, 0x00	; 0
     932:	0e 94 ae 01 	call	0x35c	; 0x35c <lcd_dispString>
			flag++;
     936:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <flag.1990>
     93a:	8f 5f       	subi	r24, 0xFF	; 255
     93c:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <flag.1990>
		}	
		if (flag == 2)
     940:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <flag.1990>
     944:	82 30       	cpi	r24, 0x02	; 2
     946:	21 f4       	brne	.+8      	; 0x950 <task2_code+0x9e>
		{
			lcd_clrScreen();
     948:	0e 94 aa 01 	call	0x354	; 0x354 <lcd_clrScreen>
			
			flag = 0;
     94c:	10 92 83 06 	sts	0x0683, r1	; 0x800683 <flag.1990>
			
		} 

		counter++; 
     950:	80 91 84 06 	lds	r24, 0x0684	; 0x800684 <counter.1991>
     954:	8f 5f       	subi	r24, 0xFF	; 255
     956:	80 93 84 06 	sts	0x0684, r24	; 0x800684 <counter.1991>
	}
     95a:	b4 cf       	rjmp	.-152    	; 0x8c4 <task2_code+0x12>

0000095c <keycheck_code>:
  }
  void keycheck_code(void*pvParamter){
     95c:	cf 93       	push	r28
     95e:	df 93       	push	r29
     960:	00 d0       	rcall	.+0      	; 0x962 <keycheck_code+0x6>
     962:	cd b7       	in	r28, 0x3d	; 61
     964:	de b7       	in	r29, 0x3e	; 62
	  portTickType count = xTaskGetTickCount(); 
     966:	0e 94 3c 08 	call	0x1078	; 0x1078 <xTaskGetTickCount>
     96a:	9a 83       	std	Y+2, r25	; 0x02
     96c:	89 83       	std	Y+1, r24	; 0x01
	  while (1)
	  {
		vTaskDelayUntil(&count,15);
     96e:	6f e0       	ldi	r22, 0x0F	; 15
     970:	70 e0       	ldi	r23, 0x00	; 0
     972:	ce 01       	movw	r24, r28
     974:	01 96       	adiw	r24, 0x01	; 1
     976:	0e 94 90 09 	call	0x1320	; 0x1320 <vTaskDelayUntil>
		u8 temp = KeyPad_u8GetPressedKey();
     97a:	0e 94 00 01 	call	0x200	; 0x200 <KeyPad_u8GetPressedKey>
		if(temp != NO_KEY_PRESSED )
     97e:	8f 3f       	cpi	r24, 0xFF	; 255
     980:	b1 f3       	breq	.-20     	; 0x96e <keycheck_code+0x12>
		{
			xTaskCreate(calc_code,NULL,85,NULL,3,&calc);
     982:	a1 2c       	mov	r10, r1
     984:	b1 2c       	mov	r11, r1
     986:	c1 2c       	mov	r12, r1
     988:	d1 2c       	mov	r13, r1
     98a:	0f 2e       	mov	r0, r31
     98c:	f6 ef       	ldi	r31, 0xF6	; 246
     98e:	ef 2e       	mov	r14, r31
     990:	f6 e0       	ldi	r31, 0x06	; 6
     992:	ff 2e       	mov	r15, r31
     994:	f0 2d       	mov	r31, r0
     996:	03 e0       	ldi	r16, 0x03	; 3
     998:	20 e0       	ldi	r18, 0x00	; 0
     99a:	30 e0       	ldi	r19, 0x00	; 0
     99c:	45 e5       	ldi	r20, 0x55	; 85
     99e:	50 e0       	ldi	r21, 0x00	; 0
     9a0:	60 e0       	ldi	r22, 0x00	; 0
     9a2:	70 e0       	ldi	r23, 0x00	; 0
     9a4:	8b e7       	ldi	r24, 0x7B	; 123
     9a6:	95 e0       	ldi	r25, 0x05	; 5
     9a8:	0e 94 b4 06 	call	0xd68	; 0xd68 <xTaskGenericCreate>
			vTaskDelete(task2);
     9ac:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <task2>
     9b0:	90 91 f9 06 	lds	r25, 0x06F9	; 0x8006f9 <task2+0x1>
     9b4:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskDelete>
			vTaskDelete(keycheck);
     9b8:	80 91 f4 06 	lds	r24, 0x06F4	; 0x8006f4 <keycheck>
     9bc:	90 91 f5 06 	lds	r25, 0x06F5	; 0x8006f5 <keycheck+0x1>
     9c0:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskDelete>
     9c4:	d4 cf       	rjmp	.-88     	; 0x96e <keycheck_code+0x12>

000009c6 <LED_code>:
		}
	  }  
  }

  
  void LED_code(void*pvParamter){
     9c6:	cf 93       	push	r28
     9c8:	df 93       	push	r29
     9ca:	00 d0       	rcall	.+0      	; 0x9cc <LED_code+0x6>
     9cc:	cd b7       	in	r28, 0x3d	; 61
     9ce:	de b7       	in	r29, 0x3e	; 62
		PWM0_Init();
     9d0:	0e 94 af 03 	call	0x75e	; 0x75e <PWM0_Init>
		portTickType count = xTaskGetTickCount(); 
     9d4:	0e 94 3c 08 	call	0x1078	; 0x1078 <xTaskGetTickCount>
     9d8:	9a 83       	std	Y+2, r25	; 0x02
     9da:	89 83       	std	Y+1, r24	; 0x01
						PWM0_SetDutyCycle(100-duty);
						duty += 10;
					}
					else{
						duty = 0;
						state=3;
     9dc:	0f 2e       	mov	r0, r31
     9de:	f3 e0       	ldi	r31, 0x03	; 3
     9e0:	ef 2e       	mov	r14, r31
     9e2:	f1 2c       	mov	r15, r1
     9e4:	f0 2d       	mov	r31, r0
				break;
				case 2:
					PWM0_Init();
					if(duty<=100)
					{
						PWM0_SetDutyCycle(100-duty);
     9e6:	0f 2e       	mov	r0, r31
     9e8:	f4 e6       	ldi	r31, 0x64	; 100
     9ea:	bf 2e       	mov	r11, r31
     9ec:	f0 2d       	mov	r31, r0
						PWM0_SetDutyCycle(duty);
						duty += 10;
					}
					else{
						duty = 0;
						state=1;
     9ee:	01 e0       	ldi	r16, 0x01	; 1
     9f0:	10 e0       	ldi	r17, 0x00	; 0
				break;
				case 1:
					PWM0_Stop();
					if (counter == 10)
					{
						state = 2;	
     9f2:	68 94       	set
     9f4:	cc 24       	eor	r12, r12
     9f6:	c1 f8       	bld	r12, 1
     9f8:	d1 2c       	mov	r13, r1
		PWM0_Init();
		portTickType count = xTaskGetTickCount(); 
		static int state = 0 ,duty = 0 ,counter = 0;
		while (1)
		{
			vTaskDelayUntil(&count,250);
     9fa:	6a ef       	ldi	r22, 0xFA	; 250
     9fc:	70 e0       	ldi	r23, 0x00	; 0
     9fe:	ce 01       	movw	r24, r28
     a00:	01 96       	adiw	r24, 0x01	; 1
     a02:	0e 94 90 09 	call	0x1320	; 0x1320 <vTaskDelayUntil>
			switch (state)
     a06:	80 91 81 06 	lds	r24, 0x0681	; 0x800681 <state.2004>
     a0a:	90 91 82 06 	lds	r25, 0x0682	; 0x800682 <state.2004+0x1>
     a0e:	81 30       	cpi	r24, 0x01	; 1
     a10:	91 05       	cpc	r25, r1
     a12:	49 f1       	breq	.+82     	; 0xa66 <LED_code+0xa0>
     a14:	1c f4       	brge	.+6      	; 0xa1c <LED_code+0x56>
     a16:	89 2b       	or	r24, r25
     a18:	41 f0       	breq	.+16     	; 0xa2a <LED_code+0x64>
     a1a:	ef cf       	rjmp	.-34     	; 0x9fa <LED_code+0x34>
     a1c:	82 30       	cpi	r24, 0x02	; 2
     a1e:	91 05       	cpc	r25, r1
     a20:	b1 f1       	breq	.+108    	; 0xa8e <LED_code+0xc8>
     a22:	03 97       	sbiw	r24, 0x03	; 3
     a24:	09 f4       	brne	.+2      	; 0xa28 <LED_code+0x62>
     a26:	54 c0       	rjmp	.+168    	; 0xad0 <LED_code+0x10a>
     a28:	e8 cf       	rjmp	.-48     	; 0x9fa <LED_code+0x34>
			{
				case 0:
					PWM0_Init();
     a2a:	0e 94 af 03 	call	0x75e	; 0x75e <PWM0_Init>
					if(duty<=100)
     a2e:	80 91 7f 06 	lds	r24, 0x067F	; 0x80067f <duty.2005>
     a32:	90 91 80 06 	lds	r25, 0x0680	; 0x800680 <duty.2005+0x1>
     a36:	85 36       	cpi	r24, 0x65	; 101
     a38:	91 05       	cpc	r25, r1
     a3a:	64 f4       	brge	.+24     	; 0xa54 <LED_code+0x8e>
					{
						PWM0_SetDutyCycle(duty);
     a3c:	0e 94 c5 03 	call	0x78a	; 0x78a <PWM0_SetDutyCycle>
						duty += 10;
     a40:	80 91 7f 06 	lds	r24, 0x067F	; 0x80067f <duty.2005>
     a44:	90 91 80 06 	lds	r25, 0x0680	; 0x800680 <duty.2005+0x1>
     a48:	0a 96       	adiw	r24, 0x0a	; 10
     a4a:	90 93 80 06 	sts	0x0680, r25	; 0x800680 <duty.2005+0x1>
     a4e:	80 93 7f 06 	sts	0x067F, r24	; 0x80067f <duty.2005>
     a52:	d3 cf       	rjmp	.-90     	; 0x9fa <LED_code+0x34>
					}
					else{
						duty = 0;
     a54:	10 92 80 06 	sts	0x0680, r1	; 0x800680 <duty.2005+0x1>
     a58:	10 92 7f 06 	sts	0x067F, r1	; 0x80067f <duty.2005>
						state=1;
     a5c:	10 93 82 06 	sts	0x0682, r17	; 0x800682 <state.2004+0x1>
     a60:	00 93 81 06 	sts	0x0681, r16	; 0x800681 <state.2004>
     a64:	ca cf       	rjmp	.-108    	; 0x9fa <LED_code+0x34>
					}
				break;
				case 1:
					PWM0_Stop();
     a66:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <PWM0_Stop>
					if (counter == 10)
     a6a:	80 91 7d 06 	lds	r24, 0x067D	; 0x80067d <counter.2006>
     a6e:	90 91 7e 06 	lds	r25, 0x067E	; 0x80067e <counter.2006+0x1>
     a72:	8a 30       	cpi	r24, 0x0A	; 10
     a74:	91 05       	cpc	r25, r1
     a76:	29 f4       	brne	.+10     	; 0xa82 <LED_code+0xbc>
					{
						state = 2;	
     a78:	d0 92 82 06 	sts	0x0682, r13	; 0x800682 <state.2004+0x1>
     a7c:	c0 92 81 06 	sts	0x0681, r12	; 0x800681 <state.2004>
     a80:	bc cf       	rjmp	.-136    	; 0x9fa <LED_code+0x34>
					}
					else{
						counter++;
     a82:	01 96       	adiw	r24, 0x01	; 1
     a84:	90 93 7e 06 	sts	0x067E, r25	; 0x80067e <counter.2006+0x1>
     a88:	80 93 7d 06 	sts	0x067D, r24	; 0x80067d <counter.2006>
     a8c:	b6 cf       	rjmp	.-148    	; 0x9fa <LED_code+0x34>
					}
				break;
				case 2:
					PWM0_Init();
     a8e:	0e 94 af 03 	call	0x75e	; 0x75e <PWM0_Init>
					if(duty<=100)
     a92:	80 91 7f 06 	lds	r24, 0x067F	; 0x80067f <duty.2005>
     a96:	90 91 80 06 	lds	r25, 0x0680	; 0x800680 <duty.2005+0x1>
     a9a:	85 36       	cpi	r24, 0x65	; 101
     a9c:	91 05       	cpc	r25, r1
     a9e:	7c f4       	brge	.+30     	; 0xabe <LED_code+0xf8>
					{
						PWM0_SetDutyCycle(100-duty);
     aa0:	2b 2d       	mov	r18, r11
     aa2:	28 1b       	sub	r18, r24
     aa4:	82 2f       	mov	r24, r18
     aa6:	0e 94 c5 03 	call	0x78a	; 0x78a <PWM0_SetDutyCycle>
						duty += 10;
     aaa:	80 91 7f 06 	lds	r24, 0x067F	; 0x80067f <duty.2005>
     aae:	90 91 80 06 	lds	r25, 0x0680	; 0x800680 <duty.2005+0x1>
     ab2:	0a 96       	adiw	r24, 0x0a	; 10
     ab4:	90 93 80 06 	sts	0x0680, r25	; 0x800680 <duty.2005+0x1>
     ab8:	80 93 7f 06 	sts	0x067F, r24	; 0x80067f <duty.2005>
     abc:	9e cf       	rjmp	.-196    	; 0x9fa <LED_code+0x34>
					}
					else{
						duty = 0;
     abe:	10 92 80 06 	sts	0x0680, r1	; 0x800680 <duty.2005+0x1>
     ac2:	10 92 7f 06 	sts	0x067F, r1	; 0x80067f <duty.2005>
						state=3;
     ac6:	f0 92 82 06 	sts	0x0682, r15	; 0x800682 <state.2004+0x1>
     aca:	e0 92 81 06 	sts	0x0681, r14	; 0x800681 <state.2004>
     ace:	95 cf       	rjmp	.-214    	; 0x9fa <LED_code+0x34>
					}
				break;
				case 3:
					PWM0_Stop();
     ad0:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <PWM0_Stop>
					if (counter == 0)
     ad4:	80 91 7d 06 	lds	r24, 0x067D	; 0x80067d <counter.2006>
     ad8:	90 91 7e 06 	lds	r25, 0x067E	; 0x80067e <counter.2006+0x1>
     adc:	00 97       	sbiw	r24, 0x00	; 0
     ade:	29 f4       	brne	.+10     	; 0xaea <LED_code+0x124>
					{
						state = 0;
     ae0:	10 92 82 06 	sts	0x0682, r1	; 0x800682 <state.2004+0x1>
     ae4:	10 92 81 06 	sts	0x0681, r1	; 0x800681 <state.2004>
     ae8:	88 cf       	rjmp	.-240    	; 0x9fa <LED_code+0x34>
					}
					else{
						counter--;
     aea:	01 97       	sbiw	r24, 0x01	; 1
     aec:	90 93 7e 06 	sts	0x067E, r25	; 0x80067e <counter.2006+0x1>
     af0:	80 93 7d 06 	sts	0x067D, r24	; 0x80067d <counter.2006>
     af4:	82 cf       	rjmp	.-252    	; 0x9fa <LED_code+0x34>

00000af6 <calc_code>:
				break;
			}
		}
	  
  }
  void calc_code(void*pvParamter){
     af6:	cf 93       	push	r28
     af8:	df 93       	push	r29
     afa:	00 d0       	rcall	.+0      	; 0xafc <calc_code+0x6>
     afc:	cd b7       	in	r28, 0x3d	; 61
     afe:	de b7       	in	r29, 0x3e	; 62
	  SIGNS op;
	  static char stk[16];
	  static unsigned char flag = 0,flag2=0;
	  static unsigned char counter = 0 , pos = 0;
	  static char val = NO_KEY_PRESSED,pre_key = NO_KEY_PRESSED; 
	  portTickType coun = xTaskGetTickCount();
     b00:	0e 94 3c 08 	call	0x1078	; 0x1078 <xTaskGetTickCount>
     b04:	9a 83       	std	Y+2, r25	; 0x02
     b06:	89 83       	std	Y+1, r24	; 0x01
					break;
					case MUL:
					lcd_displayChar('0'+ ((stk[0]-'0')*(stk[pos]-'0')));
					break;
					case SUB:
					lcd_displayChar('0'+ ((stk[0]-'0')-(stk[pos]-'0')));
     b08:	0f 2e       	mov	r0, r31
     b0a:	fc e6       	ldi	r31, 0x6C	; 108
     b0c:	6f 2e       	mov	r6, r31
     b0e:	f6 e0       	ldi	r31, 0x06	; 6
     b10:	7f 2e       	mov	r7, r31
     b12:	f0 2d       	mov	r31, r0
					break;
					case 43:
					op = ADD;
					break;
					case 45:
					op = SUB;
     b14:	0f 2e       	mov	r0, r31
     b16:	fd e0       	ldi	r31, 0x0D	; 13
     b18:	9f 2e       	mov	r9, r31
     b1a:	f0 2d       	mov	r31, r0
					break;
					case 47:
					op = DIV;
     b1c:	0f 2e       	mov	r0, r31
     b1e:	ff e0       	ldi	r31, 0x0F	; 15
     b20:	af 2e       	mov	r10, r31
     b22:	f0 2d       	mov	r31, r0
					break;	
					case 67:
					op = ON_C;
     b24:	dd 24       	eor	r13, r13
     b26:	d3 94       	inc	r13
				pos = counter;
				lcd_clrScreen();
				switch (val)
				{
					case 42: //*
					op = MUL;
     b28:	0f 2e       	mov	r0, r31
     b2a:	fe e0       	ldi	r31, 0x0E	; 14
     b2c:	bf 2e       	mov	r11, r31
     b2e:	f0 2d       	mov	r31, r0
					break;
					case 43:
					op = ADD;
     b30:	0f 2e       	mov	r0, r31
     b32:	fc e0       	ldi	r31, 0x0C	; 12
     b34:	cf 2e       	mov	r12, r31
     b36:	f0 2d       	mov	r31, r0
	  portTickType coun = xTaskGetTickCount();
	  while (1)
	  {
			vTaskDelayUntil(&coun,15);
			val = KeyPad_u8GetPressedKey();
			if(val == NO_KEY_PRESSED){pre_key = NO_KEY_PRESSED;continue;}
     b38:	ee 24       	eor	r14, r14
     b3a:	ea 94       	dec	r14
	  static unsigned char counter = 0 , pos = 0;
	  static char val = NO_KEY_PRESSED,pre_key = NO_KEY_PRESSED; 
	  portTickType coun = xTaskGetTickCount();
	  while (1)
	  {
			vTaskDelayUntil(&coun,15);
     b3c:	6f e0       	ldi	r22, 0x0F	; 15
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	ce 01       	movw	r24, r28
     b42:	01 96       	adiw	r24, 0x01	; 1
     b44:	0e 94 90 09 	call	0x1320	; 0x1320 <vTaskDelayUntil>
			val = KeyPad_u8GetPressedKey();
     b48:	0e 94 00 01 	call	0x200	; 0x200 <KeyPad_u8GetPressedKey>
     b4c:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <val.2022>
			if(val == NO_KEY_PRESSED){pre_key = NO_KEY_PRESSED;continue;}
     b50:	8f 3f       	cpi	r24, 0xFF	; 255
     b52:	19 f4       	brne	.+6      	; 0xb5a <calc_code+0x64>
     b54:	e0 92 60 00 	sts	0x0060, r14	; 0x800060 <__data_start>
     b58:	f1 cf       	rjmp	.-30     	; 0xb3c <calc_code+0x46>
			if (val == pre_key){continue;}
     b5a:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <__data_start>
     b5e:	89 17       	cp	r24, r25
     b60:	69 f3       	breq	.-38     	; 0xb3c <calc_code+0x46>
			else {pre_key = val;}
     b62:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
			if (val >= 48 && val <= 57)
     b66:	90 ed       	ldi	r25, 0xD0	; 208
     b68:	98 0f       	add	r25, r24
     b6a:	9a 30       	cpi	r25, 0x0A	; 10
     b6c:	78 f4       	brcc	.+30     	; 0xb8c <calc_code+0x96>
			{
					lcd_displayChar(val);
     b6e:	0e 94 78 01 	call	0x2f0	; 0x2f0 <lcd_displayChar>
					stk[counter] = val;
     b72:	80 91 7c 06 	lds	r24, 0x067C	; 0x80067c <counter.2020>
     b76:	e8 2f       	mov	r30, r24
     b78:	f0 e0       	ldi	r31, 0x00	; 0
     b7a:	e4 59       	subi	r30, 0x94	; 148
     b7c:	f9 4f       	sbci	r31, 0xF9	; 249
     b7e:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <val.2022>
     b82:	90 83       	st	Z, r25
					counter++;
     b84:	8f 5f       	subi	r24, 0xFF	; 255
     b86:	80 93 7c 06 	sts	0x067C, r24	; 0x80067c <counter.2020>
     b8a:	31 c0       	rjmp	.+98     	; 0xbee <calc_code+0xf8>
			}
			else if(val == 61 && pos ){ // = is pressed
     b8c:	8d 33       	cpi	r24, 0x3D	; 61
     b8e:	79 f4       	brne	.+30     	; 0xbae <calc_code+0xb8>
     b90:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <pos.2021>
     b94:	88 23       	and	r24, r24
     b96:	59 f0       	breq	.+22     	; 0xbae <calc_code+0xb8>
				flag = 1;
     b98:	d0 92 6a 06 	sts	0x066A, r13	; 0x80066a <flag.2018>
				counter = 0;
     b9c:	10 92 7c 06 	sts	0x067C, r1	; 0x80067c <counter.2020>
				lcd_clrScreen();
     ba0:	0e 94 aa 01 	call	0x354	; 0x354 <lcd_clrScreen>
				lcd_displayChar(val);
     ba4:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <val.2022>
     ba8:	0e 94 78 01 	call	0x2f0	; 0x2f0 <lcd_displayChar>
     bac:	20 c0       	rjmp	.+64     	; 0xbee <calc_code+0xf8>
			}
			else{
				pos = counter;
     bae:	80 91 7c 06 	lds	r24, 0x067C	; 0x80067c <counter.2020>
     bb2:	80 93 6b 06 	sts	0x066B, r24	; 0x80066b <pos.2021>
				lcd_clrScreen();
     bb6:	0e 94 aa 01 	call	0x354	; 0x354 <lcd_clrScreen>
				switch (val)
     bba:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <val.2022>
     bbe:	8d 32       	cpi	r24, 0x2D	; 45
     bc0:	79 f0       	breq	.+30     	; 0xbe0 <calc_code+0xea>
     bc2:	28 f4       	brcc	.+10     	; 0xbce <calc_code+0xd8>
     bc4:	8a 32       	cpi	r24, 0x2A	; 42
     bc6:	41 f0       	breq	.+16     	; 0xbd8 <calc_code+0xe2>
     bc8:	8b 32       	cpi	r24, 0x2B	; 43
     bca:	41 f0       	breq	.+16     	; 0xbdc <calc_code+0xe6>
     bcc:	0e c0       	rjmp	.+28     	; 0xbea <calc_code+0xf4>
     bce:	8f 32       	cpi	r24, 0x2F	; 47
     bd0:	49 f0       	breq	.+18     	; 0xbe4 <calc_code+0xee>
     bd2:	83 34       	cpi	r24, 0x43	; 67
     bd4:	49 f0       	breq	.+18     	; 0xbe8 <calc_code+0xf2>
     bd6:	09 c0       	rjmp	.+18     	; 0xbea <calc_code+0xf4>
				{
					case 42: //*
					op = MUL;
     bd8:	1b 2d       	mov	r17, r11
     bda:	07 c0       	rjmp	.+14     	; 0xbea <calc_code+0xf4>
					break;
					case 43:
					op = ADD;
     bdc:	1c 2d       	mov	r17, r12
					break;
     bde:	05 c0       	rjmp	.+10     	; 0xbea <calc_code+0xf4>
					case 45:
					op = SUB;
     be0:	19 2d       	mov	r17, r9
					break;
     be2:	03 c0       	rjmp	.+6      	; 0xbea <calc_code+0xf4>
					case 47:
					op = DIV;
     be4:	1a 2d       	mov	r17, r10
					break;	
     be6:	01 c0       	rjmp	.+2      	; 0xbea <calc_code+0xf4>
					case 67:
					op = ON_C;
     be8:	1d 2d       	mov	r17, r13
					break;									
				}
				lcd_displayChar(val);
     bea:	0e 94 78 01 	call	0x2f0	; 0x2f0 <lcd_displayChar>
				flag2 =1;
			}
			if (flag)
     bee:	80 91 6a 06 	lds	r24, 0x066A	; 0x80066a <flag.2018>
     bf2:	88 23       	and	r24, r24
     bf4:	09 f4       	brne	.+2      	; 0xbf8 <calc_code+0x102>
     bf6:	a2 cf       	rjmp	.-188    	; 0xb3c <calc_code+0x46>
			{
				lcd_clrScreen();
     bf8:	0e 94 aa 01 	call	0x354	; 0x354 <lcd_clrScreen>
				switch (op){
     bfc:	1d 30       	cpi	r17, 0x0D	; 13
     bfe:	41 f1       	breq	.+80     	; 0xc50 <calc_code+0x15a>
     c00:	18 f4       	brcc	.+6      	; 0xc08 <calc_code+0x112>
     c02:	1c 30       	cpi	r17, 0x0C	; 12
     c04:	31 f0       	breq	.+12     	; 0xc12 <calc_code+0x11c>
     c06:	44 c0       	rjmp	.+136    	; 0xc90 <calc_code+0x19a>
     c08:	1e 30       	cpi	r17, 0x0E	; 14
     c0a:	81 f0       	breq	.+32     	; 0xc2c <calc_code+0x136>
     c0c:	1f 30       	cpi	r17, 0x0F	; 15
     c0e:	69 f1       	breq	.+90     	; 0xc6a <calc_code+0x174>
     c10:	3f c0       	rjmp	.+126    	; 0xc90 <calc_code+0x19a>
					case ADD:
					lcd_displayChar('0'+ (stk[0]-'0')+(stk[pos]-'0'));
     c12:	e0 91 6b 06 	lds	r30, 0x066B	; 0x80066b <pos.2021>
     c16:	f0 e0       	ldi	r31, 0x00	; 0
     c18:	e4 59       	subi	r30, 0x94	; 148
     c1a:	f9 4f       	sbci	r31, 0xF9	; 249
     c1c:	d3 01       	movw	r26, r6
     c1e:	8c 91       	ld	r24, X
     c20:	80 53       	subi	r24, 0x30	; 48
     c22:	90 81       	ld	r25, Z
     c24:	89 0f       	add	r24, r25
     c26:	0e 94 78 01 	call	0x2f0	; 0x2f0 <lcd_displayChar>
					break;
     c2a:	32 c0       	rjmp	.+100    	; 0xc90 <calc_code+0x19a>
					case MUL:
					lcd_displayChar('0'+ ((stk[0]-'0')*(stk[pos]-'0')));
     c2c:	e0 91 6b 06 	lds	r30, 0x066B	; 0x80066b <pos.2021>
     c30:	f0 e0       	ldi	r31, 0x00	; 0
     c32:	e4 59       	subi	r30, 0x94	; 148
     c34:	f9 4f       	sbci	r31, 0xF9	; 249
     c36:	80 81       	ld	r24, Z
     c38:	90 ed       	ldi	r25, 0xD0	; 208
     c3a:	98 0f       	add	r25, r24
     c3c:	f3 01       	movw	r30, r6
     c3e:	80 81       	ld	r24, Z
     c40:	80 53       	subi	r24, 0x30	; 48
     c42:	89 9f       	mul	r24, r25
     c44:	80 2d       	mov	r24, r0
     c46:	11 24       	eor	r1, r1
     c48:	80 5d       	subi	r24, 0xD0	; 208
     c4a:	0e 94 78 01 	call	0x2f0	; 0x2f0 <lcd_displayChar>
					break;
     c4e:	20 c0       	rjmp	.+64     	; 0xc90 <calc_code+0x19a>
					case SUB:
					lcd_displayChar('0'+ ((stk[0]-'0')-(stk[pos]-'0')));
     c50:	d3 01       	movw	r26, r6
     c52:	8c 91       	ld	r24, X
     c54:	80 5d       	subi	r24, 0xD0	; 208
     c56:	e0 91 6b 06 	lds	r30, 0x066B	; 0x80066b <pos.2021>
     c5a:	f0 e0       	ldi	r31, 0x00	; 0
     c5c:	e4 59       	subi	r30, 0x94	; 148
     c5e:	f9 4f       	sbci	r31, 0xF9	; 249
     c60:	90 81       	ld	r25, Z
     c62:	89 1b       	sub	r24, r25
     c64:	0e 94 78 01 	call	0x2f0	; 0x2f0 <lcd_displayChar>
					break;
     c68:	13 c0       	rjmp	.+38     	; 0xc90 <calc_code+0x19a>
					case DIV:
					lcd_displayChar('0'+((stk[0]-'0')/(stk[pos]-'0')));
     c6a:	f3 01       	movw	r30, r6
     c6c:	80 81       	ld	r24, Z
     c6e:	90 e0       	ldi	r25, 0x00	; 0
     c70:	c0 97       	sbiw	r24, 0x30	; 48
     c72:	e0 91 6b 06 	lds	r30, 0x066B	; 0x80066b <pos.2021>
     c76:	f0 e0       	ldi	r31, 0x00	; 0
     c78:	e4 59       	subi	r30, 0x94	; 148
     c7a:	f9 4f       	sbci	r31, 0xF9	; 249
     c7c:	60 81       	ld	r22, Z
     c7e:	70 e0       	ldi	r23, 0x00	; 0
     c80:	60 53       	subi	r22, 0x30	; 48
     c82:	71 09       	sbc	r23, r1
     c84:	0e 94 76 0a 	call	0x14ec	; 0x14ec <__divmodhi4>
     c88:	80 e3       	ldi	r24, 0x30	; 48
     c8a:	86 0f       	add	r24, r22
     c8c:	0e 94 78 01 	call	0x2f0	; 0x2f0 <lcd_displayChar>
					break;															
	
				}
				flag=0;
     c90:	10 92 6a 06 	sts	0x066A, r1	; 0x80066a <flag.2018>
				flag2=0;
				pos = 0;
     c94:	10 92 6b 06 	sts	0x066B, r1	; 0x80066b <pos.2021>
				counter = 0;
     c98:	10 92 7c 06 	sts	0x067C, r1	; 0x80067c <counter.2020>
     c9c:	4f cf       	rjmp	.-354    	; 0xb3c <calc_code+0x46>

00000c9e <main>:
	MUL = 14,
	DIV = 15,
}SIGNS;
 
int main(void)
{
     c9e:	af 92       	push	r10
     ca0:	bf 92       	push	r11
     ca2:	cf 92       	push	r12
     ca4:	df 92       	push	r13
     ca6:	ef 92       	push	r14
     ca8:	ff 92       	push	r15
     caa:	0f 93       	push	r16
	char i = 0;
	/*initialize LCD*/
	DIO_voidInt();
     cac:	0e 94 59 00 	call	0xb2	; 0xb2 <DIO_voidInt>
	lcd_init();	
     cb0:	0e 94 67 01 	call	0x2ce	; 0x2ce <lcd_init>
	lcd_clrScreen();	
     cb4:	0e 94 aa 01 	call	0x354	; 0x354 <lcd_clrScreen>
// 	PWM0_Init();
// 	for(i;i<=100;i++){PWM0_SetDutyCycle(i);_delay_ms(10);}
// 	for(i=100;i>=0;i--){PWM0_SetDutyCycle(i);_delay_ms(10);}
	/*Create tasks*/
	xTaskCreate(task1_code,NULL,85,NULL,TASK1_PRIORITY,&welcome);
     cb8:	a1 2c       	mov	r10, r1
     cba:	b1 2c       	mov	r11, r1
     cbc:	c1 2c       	mov	r12, r1
     cbe:	d1 2c       	mov	r13, r1
     cc0:	0f 2e       	mov	r0, r31
     cc2:	fc ef       	ldi	r31, 0xFC	; 252
     cc4:	ef 2e       	mov	r14, r31
     cc6:	f6 e0       	ldi	r31, 0x06	; 6
     cc8:	ff 2e       	mov	r15, r31
     cca:	f0 2d       	mov	r31, r0
     ccc:	01 e0       	ldi	r16, 0x01	; 1
     cce:	20 e0       	ldi	r18, 0x00	; 0
     cd0:	30 e0       	ldi	r19, 0x00	; 0
     cd2:	45 e5       	ldi	r20, 0x55	; 85
     cd4:	50 e0       	ldi	r21, 0x00	; 0
     cd6:	60 e0       	ldi	r22, 0x00	; 0
     cd8:	70 e0       	ldi	r23, 0x00	; 0
     cda:	8d ed       	ldi	r24, 0xDD	; 221
     cdc:	93 e0       	ldi	r25, 0x03	; 3
     cde:	0e 94 b4 06 	call	0xd68	; 0xd68 <xTaskGenericCreate>
	/*start Scheduler */
	vTaskStartScheduler();
     ce2:	0e 94 0b 08 	call	0x1016	; 0x1016 <vTaskStartScheduler>

	return 0;
    
}
     ce6:	80 e0       	ldi	r24, 0x00	; 0
     ce8:	90 e0       	ldi	r25, 0x00	; 0
     cea:	0f 91       	pop	r16
     cec:	ff 90       	pop	r15
     cee:	ef 90       	pop	r14
     cf0:	df 90       	pop	r13
     cf2:	cf 90       	pop	r12
     cf4:	bf 90       	pop	r11
     cf6:	af 90       	pop	r10
     cf8:	08 95       	ret

00000cfa <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     cfa:	cf 93       	push	r28
     cfc:	df 93       	push	r29
     cfe:	ec 01       	movw	r28, r24
     d00:	e0 91 f2 06 	lds	r30, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     d04:	f0 91 f3 06 	lds	r31, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     d08:	93 83       	std	Z+3, r25	; 0x03
     d0a:	82 83       	std	Z+2, r24	; 0x02
     d0c:	80 91 90 06 	lds	r24, 0x0690	; 0x800690 <xTickCount>
     d10:	90 91 91 06 	lds	r25, 0x0691	; 0x800691 <xTickCount+0x1>
     d14:	c8 17       	cp	r28, r24
     d16:	d9 07       	cpc	r29, r25
     d18:	68 f4       	brcc	.+26     	; 0xd34 <prvAddCurrentTaskToDelayedList+0x3a>
     d1a:	60 91 f2 06 	lds	r22, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     d1e:	70 91 f3 06 	lds	r23, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     d22:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <pxOverflowDelayedTaskList>
     d26:	90 91 b0 06 	lds	r25, 0x06B0	; 0x8006b0 <pxOverflowDelayedTaskList+0x1>
     d2a:	6e 5f       	subi	r22, 0xFE	; 254
     d2c:	7f 4f       	sbci	r23, 0xFF	; 255
     d2e:	0e 94 f6 01 	call	0x3ec	; 0x3ec <vListInsert>
     d32:	17 c0       	rjmp	.+46     	; 0xd62 <prvAddCurrentTaskToDelayedList+0x68>
     d34:	60 91 f2 06 	lds	r22, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     d38:	70 91 f3 06 	lds	r23, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     d3c:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <pxDelayedTaskList>
     d40:	90 91 b2 06 	lds	r25, 0x06B2	; 0x8006b2 <pxDelayedTaskList+0x1>
     d44:	6e 5f       	subi	r22, 0xFE	; 254
     d46:	7f 4f       	sbci	r23, 0xFF	; 255
     d48:	0e 94 f6 01 	call	0x3ec	; 0x3ec <vListInsert>
     d4c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <xNextTaskUnblockTime>
     d50:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <xNextTaskUnblockTime+0x1>
     d54:	c8 17       	cp	r28, r24
     d56:	d9 07       	cpc	r29, r25
     d58:	20 f4       	brcc	.+8      	; 0xd62 <prvAddCurrentTaskToDelayedList+0x68>
     d5a:	d0 93 63 00 	sts	0x0063, r29	; 0x800063 <xNextTaskUnblockTime+0x1>
     d5e:	c0 93 62 00 	sts	0x0062, r28	; 0x800062 <xNextTaskUnblockTime>
     d62:	df 91       	pop	r29
     d64:	cf 91       	pop	r28
     d66:	08 95       	ret

00000d68 <xTaskGenericCreate>:
     d68:	4f 92       	push	r4
     d6a:	5f 92       	push	r5
     d6c:	6f 92       	push	r6
     d6e:	7f 92       	push	r7
     d70:	8f 92       	push	r8
     d72:	9f 92       	push	r9
     d74:	af 92       	push	r10
     d76:	bf 92       	push	r11
     d78:	cf 92       	push	r12
     d7a:	df 92       	push	r13
     d7c:	ef 92       	push	r14
     d7e:	ff 92       	push	r15
     d80:	0f 93       	push	r16
     d82:	1f 93       	push	r17
     d84:	cf 93       	push	r28
     d86:	df 93       	push	r29
     d88:	5c 01       	movw	r10, r24
     d8a:	4b 01       	movw	r8, r22
     d8c:	ea 01       	movw	r28, r20
     d8e:	29 01       	movw	r4, r18
     d90:	81 e2       	ldi	r24, 0x21	; 33
     d92:	90 e0       	ldi	r25, 0x00	; 0
     d94:	0e 94 ad 00 	call	0x15a	; 0x15a <pvPortMalloc>
     d98:	3c 01       	movw	r6, r24
     d9a:	00 97       	sbiw	r24, 0x00	; 0
     d9c:	09 f4       	brne	.+2      	; 0xda0 <xTaskGenericCreate+0x38>
     d9e:	e0 c0       	rjmp	.+448    	; 0xf60 <xTaskGenericCreate+0x1f8>
     da0:	c1 14       	cp	r12, r1
     da2:	d1 04       	cpc	r13, r1
     da4:	09 f0       	breq	.+2      	; 0xda8 <xTaskGenericCreate+0x40>
     da6:	d7 c0       	rjmp	.+430    	; 0xf56 <xTaskGenericCreate+0x1ee>
     da8:	ce 01       	movw	r24, r28
     daa:	0e 94 ad 00 	call	0x15a	; 0x15a <pvPortMalloc>
     dae:	f3 01       	movw	r30, r6
     db0:	90 8f       	std	Z+24, r25	; 0x18
     db2:	87 8b       	std	Z+23, r24	; 0x17
     db4:	00 97       	sbiw	r24, 0x00	; 0
     db6:	21 f4       	brne	.+8      	; 0xdc0 <xTaskGenericCreate+0x58>
     db8:	c3 01       	movw	r24, r6
     dba:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <vPortFree>
     dbe:	d0 c0       	rjmp	.+416    	; 0xf60 <xTaskGenericCreate+0x1f8>
     dc0:	ae 01       	movw	r20, r28
     dc2:	65 ea       	ldi	r22, 0xA5	; 165
     dc4:	70 e0       	ldi	r23, 0x00	; 0
     dc6:	0e 94 a4 0a 	call	0x1548	; 0x1548 <memset>
     dca:	21 97       	sbiw	r28, 0x01	; 1
     dcc:	f3 01       	movw	r30, r6
     dce:	87 89       	ldd	r24, Z+23	; 0x17
     dd0:	90 8d       	ldd	r25, Z+24	; 0x18
     dd2:	c8 0f       	add	r28, r24
     dd4:	d9 1f       	adc	r29, r25
     dd6:	48 e0       	ldi	r20, 0x08	; 8
     dd8:	50 e0       	ldi	r21, 0x00	; 0
     dda:	b4 01       	movw	r22, r8
     ddc:	c3 01       	movw	r24, r6
     dde:	49 96       	adiw	r24, 0x19	; 25
     de0:	0e 94 ab 0a 	call	0x1556	; 0x1556 <strncpy>
     de4:	f3 01       	movw	r30, r6
     de6:	10 a2       	std	Z+32, r1	; 0x20
     de8:	10 2f       	mov	r17, r16
     dea:	05 30       	cpi	r16, 0x05	; 5
     dec:	08 f0       	brcs	.+2      	; 0xdf0 <xTaskGenericCreate+0x88>
     dee:	14 e0       	ldi	r17, 0x04	; 4
     df0:	f3 01       	movw	r30, r6
     df2:	16 8b       	std	Z+22, r17	; 0x16
     df4:	63 01       	movw	r12, r6
     df6:	f2 e0       	ldi	r31, 0x02	; 2
     df8:	cf 0e       	add	r12, r31
     dfa:	d1 1c       	adc	r13, r1
     dfc:	c6 01       	movw	r24, r12
     dfe:	0e 94 cb 01 	call	0x396	; 0x396 <vListInitialiseItem>
     e02:	c3 01       	movw	r24, r6
     e04:	0c 96       	adiw	r24, 0x0c	; 12
     e06:	0e 94 cb 01 	call	0x396	; 0x396 <vListInitialiseItem>
     e0a:	f3 01       	movw	r30, r6
     e0c:	71 86       	std	Z+9, r7	; 0x09
     e0e:	60 86       	std	Z+8, r6	; 0x08
     e10:	85 e0       	ldi	r24, 0x05	; 5
     e12:	90 e0       	ldi	r25, 0x00	; 0
     e14:	81 1b       	sub	r24, r17
     e16:	91 09       	sbc	r25, r1
     e18:	95 87       	std	Z+13, r25	; 0x0d
     e1a:	84 87       	std	Z+12, r24	; 0x0c
     e1c:	73 8a       	std	Z+19, r7	; 0x13
     e1e:	62 8a       	std	Z+18, r6	; 0x12
     e20:	a2 01       	movw	r20, r4
     e22:	b5 01       	movw	r22, r10
     e24:	ce 01       	movw	r24, r28
     e26:	0e 94 57 02 	call	0x4ae	; 0x4ae <pxPortInitialiseStack>
     e2a:	f3 01       	movw	r30, r6
     e2c:	91 83       	std	Z+1, r25	; 0x01
     e2e:	80 83       	st	Z, r24
     e30:	e1 14       	cp	r14, r1
     e32:	f1 04       	cpc	r15, r1
     e34:	19 f0       	breq	.+6      	; 0xe3c <xTaskGenericCreate+0xd4>
     e36:	f7 01       	movw	r30, r14
     e38:	71 82       	std	Z+1, r7	; 0x01
     e3a:	60 82       	st	Z, r6
     e3c:	0f b6       	in	r0, 0x3f	; 63
     e3e:	f8 94       	cli
     e40:	0f 92       	push	r0
     e42:	80 91 92 06 	lds	r24, 0x0692	; 0x800692 <uxCurrentNumberOfTasks>
     e46:	8f 5f       	subi	r24, 0xFF	; 255
     e48:	80 93 92 06 	sts	0x0692, r24	; 0x800692 <uxCurrentNumberOfTasks>
     e4c:	80 91 f2 06 	lds	r24, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     e50:	90 91 f3 06 	lds	r25, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     e54:	89 2b       	or	r24, r25
     e56:	c9 f5       	brne	.+114    	; 0xeca <xTaskGenericCreate+0x162>
     e58:	70 92 f3 06 	sts	0x06F3, r7	; 0x8006f3 <pxCurrentTCB+0x1>
     e5c:	60 92 f2 06 	sts	0x06F2, r6	; 0x8006f2 <pxCurrentTCB>
     e60:	80 91 92 06 	lds	r24, 0x0692	; 0x800692 <uxCurrentNumberOfTasks>
     e64:	81 30       	cpi	r24, 0x01	; 1
     e66:	09 f0       	breq	.+2      	; 0xe6a <xTaskGenericCreate+0x102>
     e68:	3f c0       	rjmp	.+126    	; 0xee8 <xTaskGenericCreate+0x180>
     e6a:	c5 ec       	ldi	r28, 0xC5	; 197
     e6c:	d6 e0       	ldi	r29, 0x06	; 6
     e6e:	0f 2e       	mov	r0, r31
     e70:	f2 ef       	ldi	r31, 0xF2	; 242
     e72:	ef 2e       	mov	r14, r31
     e74:	f6 e0       	ldi	r31, 0x06	; 6
     e76:	ff 2e       	mov	r15, r31
     e78:	f0 2d       	mov	r31, r0
     e7a:	ce 01       	movw	r24, r28
     e7c:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInitialise>
     e80:	29 96       	adiw	r28, 0x09	; 9
     e82:	ce 15       	cp	r28, r14
     e84:	df 05       	cpc	r29, r15
     e86:	c9 f7       	brne	.-14     	; 0xe7a <xTaskGenericCreate+0x112>
     e88:	8c eb       	ldi	r24, 0xBC	; 188
     e8a:	96 e0       	ldi	r25, 0x06	; 6
     e8c:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInitialise>
     e90:	83 eb       	ldi	r24, 0xB3	; 179
     e92:	96 e0       	ldi	r25, 0x06	; 6
     e94:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInitialise>
     e98:	86 ea       	ldi	r24, 0xA6	; 166
     e9a:	96 e0       	ldi	r25, 0x06	; 6
     e9c:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInitialise>
     ea0:	8d e9       	ldi	r24, 0x9D	; 157
     ea2:	96 e0       	ldi	r25, 0x06	; 6
     ea4:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInitialise>
     ea8:	83 e9       	ldi	r24, 0x93	; 147
     eaa:	96 e0       	ldi	r25, 0x06	; 6
     eac:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInitialise>
     eb0:	8c eb       	ldi	r24, 0xBC	; 188
     eb2:	96 e0       	ldi	r25, 0x06	; 6
     eb4:	90 93 b2 06 	sts	0x06B2, r25	; 0x8006b2 <pxDelayedTaskList+0x1>
     eb8:	80 93 b1 06 	sts	0x06B1, r24	; 0x8006b1 <pxDelayedTaskList>
     ebc:	83 eb       	ldi	r24, 0xB3	; 179
     ebe:	96 e0       	ldi	r25, 0x06	; 6
     ec0:	90 93 b0 06 	sts	0x06B0, r25	; 0x8006b0 <pxOverflowDelayedTaskList+0x1>
     ec4:	80 93 af 06 	sts	0x06AF, r24	; 0x8006af <pxOverflowDelayedTaskList>
     ec8:	0f c0       	rjmp	.+30     	; 0xee8 <xTaskGenericCreate+0x180>
     eca:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <xSchedulerRunning>
     ece:	81 11       	cpse	r24, r1
     ed0:	0b c0       	rjmp	.+22     	; 0xee8 <xTaskGenericCreate+0x180>
     ed2:	e0 91 f2 06 	lds	r30, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     ed6:	f0 91 f3 06 	lds	r31, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     eda:	86 89       	ldd	r24, Z+22	; 0x16
     edc:	08 17       	cp	r16, r24
     ede:	20 f0       	brcs	.+8      	; 0xee8 <xTaskGenericCreate+0x180>
     ee0:	70 92 f3 06 	sts	0x06F3, r7	; 0x8006f3 <pxCurrentTCB+0x1>
     ee4:	60 92 f2 06 	sts	0x06F2, r6	; 0x8006f2 <pxCurrentTCB>
     ee8:	f3 01       	movw	r30, r6
     eea:	86 89       	ldd	r24, Z+22	; 0x16
     eec:	90 91 8f 06 	lds	r25, 0x068F	; 0x80068f <uxTopUsedPriority>
     ef0:	98 17       	cp	r25, r24
     ef2:	10 f4       	brcc	.+4      	; 0xef8 <xTaskGenericCreate+0x190>
     ef4:	80 93 8f 06 	sts	0x068F, r24	; 0x80068f <uxTopUsedPriority>
     ef8:	90 91 88 06 	lds	r25, 0x0688	; 0x800688 <uxTaskNumber>
     efc:	9f 5f       	subi	r25, 0xFF	; 255
     efe:	90 93 88 06 	sts	0x0688, r25	; 0x800688 <uxTaskNumber>
     f02:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <uxTopReadyPriority>
     f06:	98 17       	cp	r25, r24
     f08:	10 f4       	brcc	.+4      	; 0xf0e <xTaskGenericCreate+0x1a6>
     f0a:	80 93 8e 06 	sts	0x068E, r24	; 0x80068e <uxTopReadyPriority>
     f0e:	90 e0       	ldi	r25, 0x00	; 0
     f10:	9c 01       	movw	r18, r24
     f12:	22 0f       	add	r18, r18
     f14:	33 1f       	adc	r19, r19
     f16:	22 0f       	add	r18, r18
     f18:	33 1f       	adc	r19, r19
     f1a:	22 0f       	add	r18, r18
     f1c:	33 1f       	adc	r19, r19
     f1e:	82 0f       	add	r24, r18
     f20:	93 1f       	adc	r25, r19
     f22:	b6 01       	movw	r22, r12
     f24:	8b 53       	subi	r24, 0x3B	; 59
     f26:	99 4f       	sbci	r25, 0xF9	; 249
     f28:	0e 94 cf 01 	call	0x39e	; 0x39e <vListInsertEnd>
     f2c:	0f 90       	pop	r0
     f2e:	0f be       	out	0x3f, r0	; 63
     f30:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <xSchedulerRunning>
     f34:	88 23       	and	r24, r24
     f36:	59 f0       	breq	.+22     	; 0xf4e <xTaskGenericCreate+0x1e6>
     f38:	e0 91 f2 06 	lds	r30, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     f3c:	f0 91 f3 06 	lds	r31, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     f40:	86 89       	ldd	r24, Z+22	; 0x16
     f42:	80 17       	cp	r24, r16
     f44:	30 f4       	brcc	.+12     	; 0xf52 <xTaskGenericCreate+0x1ea>
     f46:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vPortYield>
     f4a:	81 e0       	ldi	r24, 0x01	; 1
     f4c:	0a c0       	rjmp	.+20     	; 0xf62 <xTaskGenericCreate+0x1fa>
     f4e:	81 e0       	ldi	r24, 0x01	; 1
     f50:	08 c0       	rjmp	.+16     	; 0xf62 <xTaskGenericCreate+0x1fa>
     f52:	81 e0       	ldi	r24, 0x01	; 1
     f54:	06 c0       	rjmp	.+12     	; 0xf62 <xTaskGenericCreate+0x1fa>
     f56:	fc 01       	movw	r30, r24
     f58:	d0 8e       	std	Z+24, r13	; 0x18
     f5a:	c7 8a       	std	Z+23, r12	; 0x17
     f5c:	c6 01       	movw	r24, r12
     f5e:	30 cf       	rjmp	.-416    	; 0xdc0 <xTaskGenericCreate+0x58>
     f60:	8f ef       	ldi	r24, 0xFF	; 255
     f62:	df 91       	pop	r29
     f64:	cf 91       	pop	r28
     f66:	1f 91       	pop	r17
     f68:	0f 91       	pop	r16
     f6a:	ff 90       	pop	r15
     f6c:	ef 90       	pop	r14
     f6e:	df 90       	pop	r13
     f70:	cf 90       	pop	r12
     f72:	bf 90       	pop	r11
     f74:	af 90       	pop	r10
     f76:	9f 90       	pop	r9
     f78:	8f 90       	pop	r8
     f7a:	7f 90       	pop	r7
     f7c:	6f 90       	pop	r6
     f7e:	5f 90       	pop	r5
     f80:	4f 90       	pop	r4
     f82:	08 95       	ret

00000f84 <vTaskDelete>:
     f84:	ef 92       	push	r14
     f86:	ff 92       	push	r15
     f88:	0f 93       	push	r16
     f8a:	1f 93       	push	r17
     f8c:	cf 93       	push	r28
     f8e:	df 93       	push	r29
     f90:	ec 01       	movw	r28, r24
     f92:	0f b6       	in	r0, 0x3f	; 63
     f94:	f8 94       	cli
     f96:	0f 92       	push	r0
     f98:	80 91 f2 06 	lds	r24, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     f9c:	90 91 f3 06 	lds	r25, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     fa0:	8c 17       	cp	r24, r28
     fa2:	9d 07       	cpc	r25, r29
     fa4:	11 f0       	breq	.+4      	; 0xfaa <vTaskDelete+0x26>
     fa6:	20 97       	sbiw	r28, 0x00	; 0
     fa8:	39 f4       	brne	.+14     	; 0xfb8 <vTaskDelete+0x34>
     faa:	c0 91 f2 06 	lds	r28, 0x06F2	; 0x8006f2 <pxCurrentTCB>
     fae:	d0 91 f3 06 	lds	r29, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
     fb2:	e1 2c       	mov	r14, r1
     fb4:	f1 2c       	mov	r15, r1
     fb6:	01 c0       	rjmp	.+2      	; 0xfba <vTaskDelete+0x36>
     fb8:	7e 01       	movw	r14, r28
     fba:	8e 01       	movw	r16, r28
     fbc:	0e 5f       	subi	r16, 0xFE	; 254
     fbe:	1f 4f       	sbci	r17, 0xFF	; 255
     fc0:	c8 01       	movw	r24, r16
     fc2:	0e 94 31 02 	call	0x462	; 0x462 <vListRemove>
     fc6:	8c 89       	ldd	r24, Y+20	; 0x14
     fc8:	9d 89       	ldd	r25, Y+21	; 0x15
     fca:	89 2b       	or	r24, r25
     fcc:	21 f0       	breq	.+8      	; 0xfd6 <vTaskDelete+0x52>
     fce:	ce 01       	movw	r24, r28
     fd0:	0c 96       	adiw	r24, 0x0c	; 12
     fd2:	0e 94 31 02 	call	0x462	; 0x462 <vListRemove>
     fd6:	b8 01       	movw	r22, r16
     fd8:	8d e9       	ldi	r24, 0x9D	; 157
     fda:	96 e0       	ldi	r25, 0x06	; 6
     fdc:	0e 94 cf 01 	call	0x39e	; 0x39e <vListInsertEnd>
     fe0:	80 91 9c 06 	lds	r24, 0x069C	; 0x80069c <uxTasksDeleted>
     fe4:	8f 5f       	subi	r24, 0xFF	; 255
     fe6:	80 93 9c 06 	sts	0x069C, r24	; 0x80069c <uxTasksDeleted>
     fea:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <uxTaskNumber>
     fee:	8f 5f       	subi	r24, 0xFF	; 255
     ff0:	80 93 88 06 	sts	0x0688, r24	; 0x800688 <uxTaskNumber>
     ff4:	0f 90       	pop	r0
     ff6:	0f be       	out	0x3f, r0	; 63
     ff8:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <xSchedulerRunning>
     ffc:	88 23       	and	r24, r24
     ffe:	21 f0       	breq	.+8      	; 0x1008 <vTaskDelete+0x84>
    1000:	ef 28       	or	r14, r15
    1002:	11 f4       	brne	.+4      	; 0x1008 <vTaskDelete+0x84>
    1004:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vPortYield>
    1008:	df 91       	pop	r29
    100a:	cf 91       	pop	r28
    100c:	1f 91       	pop	r17
    100e:	0f 91       	pop	r16
    1010:	ff 90       	pop	r15
    1012:	ef 90       	pop	r14
    1014:	08 95       	ret

00001016 <vTaskStartScheduler>:
    1016:	af 92       	push	r10
    1018:	bf 92       	push	r11
    101a:	cf 92       	push	r12
    101c:	df 92       	push	r13
    101e:	ef 92       	push	r14
    1020:	ff 92       	push	r15
    1022:	0f 93       	push	r16
    1024:	a1 2c       	mov	r10, r1
    1026:	b1 2c       	mov	r11, r1
    1028:	c1 2c       	mov	r12, r1
    102a:	d1 2c       	mov	r13, r1
    102c:	e1 2c       	mov	r14, r1
    102e:	f1 2c       	mov	r15, r1
    1030:	00 e0       	ldi	r16, 0x00	; 0
    1032:	20 e0       	ldi	r18, 0x00	; 0
    1034:	30 e0       	ldi	r19, 0x00	; 0
    1036:	45 e5       	ldi	r20, 0x55	; 85
    1038:	50 e0       	ldi	r21, 0x00	; 0
    103a:	66 e8       	ldi	r22, 0x86	; 134
    103c:	70 e0       	ldi	r23, 0x00	; 0
    103e:	8a ed       	ldi	r24, 0xDA	; 218
    1040:	99 e0       	ldi	r25, 0x09	; 9
    1042:	0e 94 b4 06 	call	0xd68	; 0xd68 <xTaskGenericCreate>
    1046:	81 30       	cpi	r24, 0x01	; 1
    1048:	49 f4       	brne	.+18     	; 0x105c <vTaskStartScheduler+0x46>
    104a:	f8 94       	cli
    104c:	80 93 8d 06 	sts	0x068D, r24	; 0x80068d <xSchedulerRunning>
    1050:	10 92 91 06 	sts	0x0691, r1	; 0x800691 <xTickCount+0x1>
    1054:	10 92 90 06 	sts	0x0690, r1	; 0x800690 <xTickCount>
    1058:	0e 94 c3 02 	call	0x586	; 0x586 <xPortStartScheduler>
    105c:	0f 91       	pop	r16
    105e:	ff 90       	pop	r15
    1060:	ef 90       	pop	r14
    1062:	df 90       	pop	r13
    1064:	cf 90       	pop	r12
    1066:	bf 90       	pop	r11
    1068:	af 90       	pop	r10
    106a:	08 95       	ret

0000106c <vTaskSuspendAll>:
    106c:	80 91 8c 06 	lds	r24, 0x068C	; 0x80068c <uxSchedulerSuspended>
    1070:	8f 5f       	subi	r24, 0xFF	; 255
    1072:	80 93 8c 06 	sts	0x068C, r24	; 0x80068c <uxSchedulerSuspended>
    1076:	08 95       	ret

00001078 <xTaskGetTickCount>:
    1078:	0f b6       	in	r0, 0x3f	; 63
    107a:	f8 94       	cli
    107c:	0f 92       	push	r0
    107e:	80 91 90 06 	lds	r24, 0x0690	; 0x800690 <xTickCount>
    1082:	90 91 91 06 	lds	r25, 0x0691	; 0x800691 <xTickCount+0x1>
    1086:	0f 90       	pop	r0
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	08 95       	ret

0000108c <vTaskIncrementTick>:
    108c:	0f 93       	push	r16
    108e:	1f 93       	push	r17
    1090:	cf 93       	push	r28
    1092:	df 93       	push	r29
    1094:	80 91 8c 06 	lds	r24, 0x068C	; 0x80068c <uxSchedulerSuspended>
    1098:	81 11       	cpse	r24, r1
    109a:	b2 c0       	rjmp	.+356    	; 0x1200 <vTaskIncrementTick+0x174>
    109c:	80 91 90 06 	lds	r24, 0x0690	; 0x800690 <xTickCount>
    10a0:	90 91 91 06 	lds	r25, 0x0691	; 0x800691 <xTickCount+0x1>
    10a4:	01 96       	adiw	r24, 0x01	; 1
    10a6:	90 93 91 06 	sts	0x0691, r25	; 0x800691 <xTickCount+0x1>
    10aa:	80 93 90 06 	sts	0x0690, r24	; 0x800690 <xTickCount>
    10ae:	80 91 90 06 	lds	r24, 0x0690	; 0x800690 <xTickCount>
    10b2:	90 91 91 06 	lds	r25, 0x0691	; 0x800691 <xTickCount+0x1>
    10b6:	89 2b       	or	r24, r25
    10b8:	99 f5       	brne	.+102    	; 0x1120 <vTaskIncrementTick+0x94>
    10ba:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <pxDelayedTaskList>
    10be:	90 91 b2 06 	lds	r25, 0x06B2	; 0x8006b2 <pxDelayedTaskList+0x1>
    10c2:	20 91 af 06 	lds	r18, 0x06AF	; 0x8006af <pxOverflowDelayedTaskList>
    10c6:	30 91 b0 06 	lds	r19, 0x06B0	; 0x8006b0 <pxOverflowDelayedTaskList+0x1>
    10ca:	30 93 b2 06 	sts	0x06B2, r19	; 0x8006b2 <pxDelayedTaskList+0x1>
    10ce:	20 93 b1 06 	sts	0x06B1, r18	; 0x8006b1 <pxDelayedTaskList>
    10d2:	90 93 b0 06 	sts	0x06B0, r25	; 0x8006b0 <pxOverflowDelayedTaskList+0x1>
    10d6:	80 93 af 06 	sts	0x06AF, r24	; 0x8006af <pxOverflowDelayedTaskList>
    10da:	80 91 89 06 	lds	r24, 0x0689	; 0x800689 <xNumOfOverflows>
    10de:	8f 5f       	subi	r24, 0xFF	; 255
    10e0:	80 93 89 06 	sts	0x0689, r24	; 0x800689 <xNumOfOverflows>
    10e4:	e0 91 b1 06 	lds	r30, 0x06B1	; 0x8006b1 <pxDelayedTaskList>
    10e8:	f0 91 b2 06 	lds	r31, 0x06B2	; 0x8006b2 <pxDelayedTaskList+0x1>
    10ec:	80 81       	ld	r24, Z
    10ee:	81 11       	cpse	r24, r1
    10f0:	07 c0       	rjmp	.+14     	; 0x1100 <vTaskIncrementTick+0x74>
    10f2:	8f ef       	ldi	r24, 0xFF	; 255
    10f4:	9f ef       	ldi	r25, 0xFF	; 255
    10f6:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <xNextTaskUnblockTime+0x1>
    10fa:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <xNextTaskUnblockTime>
    10fe:	10 c0       	rjmp	.+32     	; 0x1120 <vTaskIncrementTick+0x94>
    1100:	e0 91 b1 06 	lds	r30, 0x06B1	; 0x8006b1 <pxDelayedTaskList>
    1104:	f0 91 b2 06 	lds	r31, 0x06B2	; 0x8006b2 <pxDelayedTaskList+0x1>
    1108:	05 80       	ldd	r0, Z+5	; 0x05
    110a:	f6 81       	ldd	r31, Z+6	; 0x06
    110c:	e0 2d       	mov	r30, r0
    110e:	06 80       	ldd	r0, Z+6	; 0x06
    1110:	f7 81       	ldd	r31, Z+7	; 0x07
    1112:	e0 2d       	mov	r30, r0
    1114:	82 81       	ldd	r24, Z+2	; 0x02
    1116:	93 81       	ldd	r25, Z+3	; 0x03
    1118:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <xNextTaskUnblockTime+0x1>
    111c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <xNextTaskUnblockTime>
    1120:	20 91 90 06 	lds	r18, 0x0690	; 0x800690 <xTickCount>
    1124:	30 91 91 06 	lds	r19, 0x0691	; 0x800691 <xTickCount+0x1>
    1128:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <xNextTaskUnblockTime>
    112c:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <xNextTaskUnblockTime+0x1>
    1130:	28 17       	cp	r18, r24
    1132:	39 07       	cpc	r19, r25
    1134:	08 f4       	brcc	.+2      	; 0x1138 <vTaskIncrementTick+0xac>
    1136:	69 c0       	rjmp	.+210    	; 0x120a <vTaskIncrementTick+0x17e>
    1138:	e0 91 b1 06 	lds	r30, 0x06B1	; 0x8006b1 <pxDelayedTaskList>
    113c:	f0 91 b2 06 	lds	r31, 0x06B2	; 0x8006b2 <pxDelayedTaskList+0x1>
    1140:	80 81       	ld	r24, Z
    1142:	88 23       	and	r24, r24
    1144:	99 f0       	breq	.+38     	; 0x116c <vTaskIncrementTick+0xe0>
    1146:	e0 91 b1 06 	lds	r30, 0x06B1	; 0x8006b1 <pxDelayedTaskList>
    114a:	f0 91 b2 06 	lds	r31, 0x06B2	; 0x8006b2 <pxDelayedTaskList+0x1>
    114e:	05 80       	ldd	r0, Z+5	; 0x05
    1150:	f6 81       	ldd	r31, Z+6	; 0x06
    1152:	e0 2d       	mov	r30, r0
    1154:	c6 81       	ldd	r28, Z+6	; 0x06
    1156:	d7 81       	ldd	r29, Z+7	; 0x07
    1158:	8a 81       	ldd	r24, Y+2	; 0x02
    115a:	9b 81       	ldd	r25, Y+3	; 0x03
    115c:	20 91 90 06 	lds	r18, 0x0690	; 0x800690 <xTickCount>
    1160:	30 91 91 06 	lds	r19, 0x0691	; 0x800691 <xTickCount+0x1>
    1164:	28 17       	cp	r18, r24
    1166:	39 07       	cpc	r19, r25
    1168:	f8 f4       	brcc	.+62     	; 0x11a8 <vTaskIncrementTick+0x11c>
    116a:	19 c0       	rjmp	.+50     	; 0x119e <vTaskIncrementTick+0x112>
    116c:	8f ef       	ldi	r24, 0xFF	; 255
    116e:	9f ef       	ldi	r25, 0xFF	; 255
    1170:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <xNextTaskUnblockTime+0x1>
    1174:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <xNextTaskUnblockTime>
    1178:	48 c0       	rjmp	.+144    	; 0x120a <vTaskIncrementTick+0x17e>
    117a:	e0 91 b1 06 	lds	r30, 0x06B1	; 0x8006b1 <pxDelayedTaskList>
    117e:	f0 91 b2 06 	lds	r31, 0x06B2	; 0x8006b2 <pxDelayedTaskList+0x1>
    1182:	05 80       	ldd	r0, Z+5	; 0x05
    1184:	f6 81       	ldd	r31, Z+6	; 0x06
    1186:	e0 2d       	mov	r30, r0
    1188:	c6 81       	ldd	r28, Z+6	; 0x06
    118a:	d7 81       	ldd	r29, Z+7	; 0x07
    118c:	8a 81       	ldd	r24, Y+2	; 0x02
    118e:	9b 81       	ldd	r25, Y+3	; 0x03
    1190:	20 91 90 06 	lds	r18, 0x0690	; 0x800690 <xTickCount>
    1194:	30 91 91 06 	lds	r19, 0x0691	; 0x800691 <xTickCount+0x1>
    1198:	28 17       	cp	r18, r24
    119a:	39 07       	cpc	r19, r25
    119c:	28 f4       	brcc	.+10     	; 0x11a8 <vTaskIncrementTick+0x11c>
    119e:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <xNextTaskUnblockTime+0x1>
    11a2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <xNextTaskUnblockTime>
    11a6:	31 c0       	rjmp	.+98     	; 0x120a <vTaskIncrementTick+0x17e>
    11a8:	8e 01       	movw	r16, r28
    11aa:	0e 5f       	subi	r16, 0xFE	; 254
    11ac:	1f 4f       	sbci	r17, 0xFF	; 255
    11ae:	c8 01       	movw	r24, r16
    11b0:	0e 94 31 02 	call	0x462	; 0x462 <vListRemove>
    11b4:	8c 89       	ldd	r24, Y+20	; 0x14
    11b6:	9d 89       	ldd	r25, Y+21	; 0x15
    11b8:	89 2b       	or	r24, r25
    11ba:	21 f0       	breq	.+8      	; 0x11c4 <vTaskIncrementTick+0x138>
    11bc:	ce 01       	movw	r24, r28
    11be:	0c 96       	adiw	r24, 0x0c	; 12
    11c0:	0e 94 31 02 	call	0x462	; 0x462 <vListRemove>
    11c4:	8e 89       	ldd	r24, Y+22	; 0x16
    11c6:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <uxTopReadyPriority>
    11ca:	98 17       	cp	r25, r24
    11cc:	10 f4       	brcc	.+4      	; 0x11d2 <vTaskIncrementTick+0x146>
    11ce:	80 93 8e 06 	sts	0x068E, r24	; 0x80068e <uxTopReadyPriority>
    11d2:	90 e0       	ldi	r25, 0x00	; 0
    11d4:	9c 01       	movw	r18, r24
    11d6:	22 0f       	add	r18, r18
    11d8:	33 1f       	adc	r19, r19
    11da:	22 0f       	add	r18, r18
    11dc:	33 1f       	adc	r19, r19
    11de:	22 0f       	add	r18, r18
    11e0:	33 1f       	adc	r19, r19
    11e2:	82 0f       	add	r24, r18
    11e4:	93 1f       	adc	r25, r19
    11e6:	b8 01       	movw	r22, r16
    11e8:	8b 53       	subi	r24, 0x3B	; 59
    11ea:	99 4f       	sbci	r25, 0xF9	; 249
    11ec:	0e 94 cf 01 	call	0x39e	; 0x39e <vListInsertEnd>
    11f0:	e0 91 b1 06 	lds	r30, 0x06B1	; 0x8006b1 <pxDelayedTaskList>
    11f4:	f0 91 b2 06 	lds	r31, 0x06B2	; 0x8006b2 <pxDelayedTaskList+0x1>
    11f8:	80 81       	ld	r24, Z
    11fa:	81 11       	cpse	r24, r1
    11fc:	be cf       	rjmp	.-132    	; 0x117a <vTaskIncrementTick+0xee>
    11fe:	b6 cf       	rjmp	.-148    	; 0x116c <vTaskIncrementTick+0xe0>
    1200:	80 91 8b 06 	lds	r24, 0x068B	; 0x80068b <uxMissedTicks>
    1204:	8f 5f       	subi	r24, 0xFF	; 255
    1206:	80 93 8b 06 	sts	0x068B, r24	; 0x80068b <uxMissedTicks>
    120a:	df 91       	pop	r29
    120c:	cf 91       	pop	r28
    120e:	1f 91       	pop	r17
    1210:	0f 91       	pop	r16
    1212:	08 95       	ret

00001214 <xTaskResumeAll>:
    1214:	cf 92       	push	r12
    1216:	df 92       	push	r13
    1218:	ef 92       	push	r14
    121a:	ff 92       	push	r15
    121c:	0f 93       	push	r16
    121e:	1f 93       	push	r17
    1220:	cf 93       	push	r28
    1222:	df 93       	push	r29
    1224:	0f b6       	in	r0, 0x3f	; 63
    1226:	f8 94       	cli
    1228:	0f 92       	push	r0
    122a:	80 91 8c 06 	lds	r24, 0x068C	; 0x80068c <uxSchedulerSuspended>
    122e:	81 50       	subi	r24, 0x01	; 1
    1230:	80 93 8c 06 	sts	0x068C, r24	; 0x80068c <uxSchedulerSuspended>
    1234:	80 91 8c 06 	lds	r24, 0x068C	; 0x80068c <uxSchedulerSuspended>
    1238:	81 11       	cpse	r24, r1
    123a:	64 c0       	rjmp	.+200    	; 0x1304 <xTaskResumeAll+0xf0>
    123c:	80 91 92 06 	lds	r24, 0x0692	; 0x800692 <uxCurrentNumberOfTasks>
    1240:	81 11       	cpse	r24, r1
    1242:	32 c0       	rjmp	.+100    	; 0x12a8 <xTaskResumeAll+0x94>
    1244:	62 c0       	rjmp	.+196    	; 0x130a <xTaskResumeAll+0xf6>
    1246:	d7 01       	movw	r26, r14
    1248:	15 96       	adiw	r26, 0x05	; 5
    124a:	ed 91       	ld	r30, X+
    124c:	fc 91       	ld	r31, X
    124e:	16 97       	sbiw	r26, 0x06	; 6
    1250:	c6 81       	ldd	r28, Z+6	; 0x06
    1252:	d7 81       	ldd	r29, Z+7	; 0x07
    1254:	ce 01       	movw	r24, r28
    1256:	0c 96       	adiw	r24, 0x0c	; 12
    1258:	0e 94 31 02 	call	0x462	; 0x462 <vListRemove>
    125c:	8e 01       	movw	r16, r28
    125e:	0e 5f       	subi	r16, 0xFE	; 254
    1260:	1f 4f       	sbci	r17, 0xFF	; 255
    1262:	c8 01       	movw	r24, r16
    1264:	0e 94 31 02 	call	0x462	; 0x462 <vListRemove>
    1268:	8e 89       	ldd	r24, Y+22	; 0x16
    126a:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <uxTopReadyPriority>
    126e:	98 17       	cp	r25, r24
    1270:	10 f4       	brcc	.+4      	; 0x1276 <xTaskResumeAll+0x62>
    1272:	80 93 8e 06 	sts	0x068E, r24	; 0x80068e <uxTopReadyPriority>
    1276:	90 e0       	ldi	r25, 0x00	; 0
    1278:	9c 01       	movw	r18, r24
    127a:	22 0f       	add	r18, r18
    127c:	33 1f       	adc	r19, r19
    127e:	22 0f       	add	r18, r18
    1280:	33 1f       	adc	r19, r19
    1282:	22 0f       	add	r18, r18
    1284:	33 1f       	adc	r19, r19
    1286:	82 0f       	add	r24, r18
    1288:	93 1f       	adc	r25, r19
    128a:	b8 01       	movw	r22, r16
    128c:	8b 53       	subi	r24, 0x3B	; 59
    128e:	99 4f       	sbci	r25, 0xF9	; 249
    1290:	0e 94 cf 01 	call	0x39e	; 0x39e <vListInsertEnd>
    1294:	e0 91 f2 06 	lds	r30, 0x06F2	; 0x8006f2 <pxCurrentTCB>
    1298:	f0 91 f3 06 	lds	r31, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
    129c:	9e 89       	ldd	r25, Y+22	; 0x16
    129e:	86 89       	ldd	r24, Z+22	; 0x16
    12a0:	98 17       	cp	r25, r24
    12a2:	58 f0       	brcs	.+22     	; 0x12ba <xTaskResumeAll+0xa6>
    12a4:	dc 2c       	mov	r13, r12
    12a6:	09 c0       	rjmp	.+18     	; 0x12ba <xTaskResumeAll+0xa6>
    12a8:	d1 2c       	mov	r13, r1
    12aa:	0f 2e       	mov	r0, r31
    12ac:	f6 ea       	ldi	r31, 0xA6	; 166
    12ae:	ef 2e       	mov	r14, r31
    12b0:	f6 e0       	ldi	r31, 0x06	; 6
    12b2:	ff 2e       	mov	r15, r31
    12b4:	f0 2d       	mov	r31, r0
    12b6:	cc 24       	eor	r12, r12
    12b8:	c3 94       	inc	r12
    12ba:	f7 01       	movw	r30, r14
    12bc:	80 81       	ld	r24, Z
    12be:	81 11       	cpse	r24, r1
    12c0:	c2 cf       	rjmp	.-124    	; 0x1246 <xTaskResumeAll+0x32>
    12c2:	80 91 8b 06 	lds	r24, 0x068B	; 0x80068b <uxMissedTicks>
    12c6:	88 23       	and	r24, r24
    12c8:	81 f0       	breq	.+32     	; 0x12ea <xTaskResumeAll+0xd6>
    12ca:	80 91 8b 06 	lds	r24, 0x068B	; 0x80068b <uxMissedTicks>
    12ce:	88 23       	and	r24, r24
    12d0:	99 f0       	breq	.+38     	; 0x12f8 <xTaskResumeAll+0xe4>
    12d2:	0e 94 46 08 	call	0x108c	; 0x108c <vTaskIncrementTick>
    12d6:	80 91 8b 06 	lds	r24, 0x068B	; 0x80068b <uxMissedTicks>
    12da:	81 50       	subi	r24, 0x01	; 1
    12dc:	80 93 8b 06 	sts	0x068B, r24	; 0x80068b <uxMissedTicks>
    12e0:	80 91 8b 06 	lds	r24, 0x068B	; 0x80068b <uxMissedTicks>
    12e4:	81 11       	cpse	r24, r1
    12e6:	f5 cf       	rjmp	.-22     	; 0x12d2 <xTaskResumeAll+0xbe>
    12e8:	07 c0       	rjmp	.+14     	; 0x12f8 <xTaskResumeAll+0xe4>
    12ea:	f1 e0       	ldi	r31, 0x01	; 1
    12ec:	df 16       	cp	r13, r31
    12ee:	21 f0       	breq	.+8      	; 0x12f8 <xTaskResumeAll+0xe4>
    12f0:	80 91 8a 06 	lds	r24, 0x068A	; 0x80068a <xMissedYield>
    12f4:	81 30       	cpi	r24, 0x01	; 1
    12f6:	41 f4       	brne	.+16     	; 0x1308 <xTaskResumeAll+0xf4>
    12f8:	10 92 8a 06 	sts	0x068A, r1	; 0x80068a <xMissedYield>
    12fc:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vPortYield>
    1300:	81 e0       	ldi	r24, 0x01	; 1
    1302:	03 c0       	rjmp	.+6      	; 0x130a <xTaskResumeAll+0xf6>
    1304:	80 e0       	ldi	r24, 0x00	; 0
    1306:	01 c0       	rjmp	.+2      	; 0x130a <xTaskResumeAll+0xf6>
    1308:	80 e0       	ldi	r24, 0x00	; 0
    130a:	0f 90       	pop	r0
    130c:	0f be       	out	0x3f, r0	; 63
    130e:	df 91       	pop	r29
    1310:	cf 91       	pop	r28
    1312:	1f 91       	pop	r17
    1314:	0f 91       	pop	r16
    1316:	ff 90       	pop	r15
    1318:	ef 90       	pop	r14
    131a:	df 90       	pop	r13
    131c:	cf 90       	pop	r12
    131e:	08 95       	ret

00001320 <vTaskDelayUntil>:
    1320:	0f 93       	push	r16
    1322:	1f 93       	push	r17
    1324:	cf 93       	push	r28
    1326:	df 93       	push	r29
    1328:	8c 01       	movw	r16, r24
    132a:	eb 01       	movw	r28, r22
    132c:	0e 94 36 08 	call	0x106c	; 0x106c <vTaskSuspendAll>
    1330:	f8 01       	movw	r30, r16
    1332:	80 81       	ld	r24, Z
    1334:	91 81       	ldd	r25, Z+1	; 0x01
    1336:	c8 0f       	add	r28, r24
    1338:	d9 1f       	adc	r29, r25
    133a:	20 91 90 06 	lds	r18, 0x0690	; 0x800690 <xTickCount>
    133e:	30 91 91 06 	lds	r19, 0x0691	; 0x800691 <xTickCount+0x1>
    1342:	28 17       	cp	r18, r24
    1344:	39 07       	cpc	r19, r25
    1346:	68 f4       	brcc	.+26     	; 0x1362 <vTaskDelayUntil+0x42>
    1348:	c8 17       	cp	r28, r24
    134a:	d9 07       	cpc	r29, r25
    134c:	50 f5       	brcc	.+84     	; 0x13a2 <vTaskDelayUntil+0x82>
    134e:	80 91 90 06 	lds	r24, 0x0690	; 0x800690 <xTickCount>
    1352:	90 91 91 06 	lds	r25, 0x0691	; 0x800691 <xTickCount+0x1>
    1356:	d1 83       	std	Z+1, r29	; 0x01
    1358:	c0 83       	st	Z, r28
    135a:	8c 17       	cp	r24, r28
    135c:	9d 07       	cpc	r25, r29
    135e:	b0 f4       	brcc	.+44     	; 0x138c <vTaskDelayUntil+0x6c>
    1360:	0b c0       	rjmp	.+22     	; 0x1378 <vTaskDelayUntil+0x58>
    1362:	c8 17       	cp	r28, r24
    1364:	d9 07       	cpc	r29, r25
    1366:	c8 f0       	brcs	.+50     	; 0x139a <vTaskDelayUntil+0x7a>
    1368:	80 91 90 06 	lds	r24, 0x0690	; 0x800690 <xTickCount>
    136c:	90 91 91 06 	lds	r25, 0x0691	; 0x800691 <xTickCount+0x1>
    1370:	8c 17       	cp	r24, r28
    1372:	9d 07       	cpc	r25, r29
    1374:	90 f0       	brcs	.+36     	; 0x139a <vTaskDelayUntil+0x7a>
    1376:	15 c0       	rjmp	.+42     	; 0x13a2 <vTaskDelayUntil+0x82>
    1378:	80 91 f2 06 	lds	r24, 0x06F2	; 0x8006f2 <pxCurrentTCB>
    137c:	90 91 f3 06 	lds	r25, 0x06F3	; 0x8006f3 <pxCurrentTCB+0x1>
    1380:	02 96       	adiw	r24, 0x02	; 2
    1382:	0e 94 31 02 	call	0x462	; 0x462 <vListRemove>
    1386:	ce 01       	movw	r24, r28
    1388:	0e 94 7d 06 	call	0xcfa	; 0xcfa <prvAddCurrentTaskToDelayedList>
    138c:	0e 94 0a 09 	call	0x1214	; 0x1214 <xTaskResumeAll>
    1390:	81 11       	cpse	r24, r1
    1392:	0b c0       	rjmp	.+22     	; 0x13aa <vTaskDelayUntil+0x8a>
    1394:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vPortYield>
    1398:	08 c0       	rjmp	.+16     	; 0x13aa <vTaskDelayUntil+0x8a>
    139a:	f8 01       	movw	r30, r16
    139c:	d1 83       	std	Z+1, r29	; 0x01
    139e:	c0 83       	st	Z, r28
    13a0:	eb cf       	rjmp	.-42     	; 0x1378 <vTaskDelayUntil+0x58>
    13a2:	f8 01       	movw	r30, r16
    13a4:	d1 83       	std	Z+1, r29	; 0x01
    13a6:	c0 83       	st	Z, r28
    13a8:	f1 cf       	rjmp	.-30     	; 0x138c <vTaskDelayUntil+0x6c>
    13aa:	df 91       	pop	r29
    13ac:	cf 91       	pop	r28
    13ae:	1f 91       	pop	r17
    13b0:	0f 91       	pop	r16
    13b2:	08 95       	ret

000013b4 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    13b4:	0d e9       	ldi	r16, 0x9D	; 157
    13b6:	16 e0       	ldi	r17, 0x06	; 6
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    13b8:	80 91 9c 06 	lds	r24, 0x069C	; 0x80069c <uxTasksDeleted>
    13bc:	88 23       	and	r24, r24
    13be:	e1 f3       	breq	.-8      	; 0x13b8 <prvIdleTask+0x4>
		{
			vTaskSuspendAll();
    13c0:	0e 94 36 08 	call	0x106c	; 0x106c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    13c4:	d8 01       	movw	r26, r16
    13c6:	cc 91       	ld	r28, X
			xTaskResumeAll();
    13c8:	0e 94 0a 09 	call	0x1214	; 0x1214 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    13cc:	cc 23       	and	r28, r28
    13ce:	a1 f3       	breq	.-24     	; 0x13b8 <prvIdleTask+0x4>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    13d0:	0f b6       	in	r0, 0x3f	; 63
    13d2:	f8 94       	cli
    13d4:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    13d6:	d8 01       	movw	r26, r16
    13d8:	15 96       	adiw	r26, 0x05	; 5
    13da:	ed 91       	ld	r30, X+
    13dc:	fc 91       	ld	r31, X
    13de:	16 97       	sbiw	r26, 0x06	; 6
    13e0:	c6 81       	ldd	r28, Z+6	; 0x06
    13e2:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    13e4:	ce 01       	movw	r24, r28
    13e6:	02 96       	adiw	r24, 0x02	; 2
    13e8:	0e 94 31 02 	call	0x462	; 0x462 <vListRemove>
					--uxCurrentNumberOfTasks;
    13ec:	80 91 92 06 	lds	r24, 0x0692	; 0x800692 <uxCurrentNumberOfTasks>
    13f0:	81 50       	subi	r24, 0x01	; 1
    13f2:	80 93 92 06 	sts	0x0692, r24	; 0x800692 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    13f6:	80 91 9c 06 	lds	r24, 0x069C	; 0x80069c <uxTasksDeleted>
    13fa:	81 50       	subi	r24, 0x01	; 1
    13fc:	80 93 9c 06 	sts	0x069C, r24	; 0x80069c <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    1400:	0f 90       	pop	r0
    1402:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1404:	8f 89       	ldd	r24, Y+23	; 0x17
    1406:	98 8d       	ldd	r25, Y+24	; 0x18
    1408:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <vPortFree>
		vPortFree( pxTCB );
    140c:	ce 01       	movw	r24, r28
    140e:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <vPortFree>
    1412:	d2 cf       	rjmp	.-92     	; 0x13b8 <prvIdleTask+0x4>

00001414 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1414:	80 91 8c 06 	lds	r24, 0x068C	; 0x80068c <uxSchedulerSuspended>
    1418:	81 11       	cpse	r24, r1
    141a:	13 c0       	rjmp	.+38     	; 0x1442 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    141c:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <uxTopReadyPriority>
    1420:	90 e0       	ldi	r25, 0x00	; 0
    1422:	fc 01       	movw	r30, r24
    1424:	ee 0f       	add	r30, r30
    1426:	ff 1f       	adc	r31, r31
    1428:	ee 0f       	add	r30, r30
    142a:	ff 1f       	adc	r31, r31
    142c:	ee 0f       	add	r30, r30
    142e:	ff 1f       	adc	r31, r31
    1430:	8e 0f       	add	r24, r30
    1432:	9f 1f       	adc	r25, r31
    1434:	fc 01       	movw	r30, r24
    1436:	eb 53       	subi	r30, 0x3B	; 59
    1438:	f9 4f       	sbci	r31, 0xF9	; 249
    143a:	80 81       	ld	r24, Z
    143c:	88 23       	and	r24, r24
    143e:	29 f0       	breq	.+10     	; 0x144a <vTaskSwitchContext+0x36>
    1440:	1b c0       	rjmp	.+54     	; 0x1478 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1442:	81 e0       	ldi	r24, 0x01	; 1
    1444:	80 93 8a 06 	sts	0x068A, r24	; 0x80068a <xMissedYield>
    1448:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    144a:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <uxTopReadyPriority>
    144e:	81 50       	subi	r24, 0x01	; 1
    1450:	80 93 8e 06 	sts	0x068E, r24	; 0x80068e <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1454:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <uxTopReadyPriority>
    1458:	90 e0       	ldi	r25, 0x00	; 0
    145a:	fc 01       	movw	r30, r24
    145c:	ee 0f       	add	r30, r30
    145e:	ff 1f       	adc	r31, r31
    1460:	ee 0f       	add	r30, r30
    1462:	ff 1f       	adc	r31, r31
    1464:	ee 0f       	add	r30, r30
    1466:	ff 1f       	adc	r31, r31
    1468:	8e 0f       	add	r24, r30
    146a:	9f 1f       	adc	r25, r31
    146c:	fc 01       	movw	r30, r24
    146e:	eb 53       	subi	r30, 0x3B	; 59
    1470:	f9 4f       	sbci	r31, 0xF9	; 249
    1472:	80 81       	ld	r24, Z
    1474:	88 23       	and	r24, r24
    1476:	49 f3       	breq	.-46     	; 0x144a <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1478:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <uxTopReadyPriority>
    147c:	90 e0       	ldi	r25, 0x00	; 0
    147e:	9c 01       	movw	r18, r24
    1480:	22 0f       	add	r18, r18
    1482:	33 1f       	adc	r19, r19
    1484:	22 0f       	add	r18, r18
    1486:	33 1f       	adc	r19, r19
    1488:	22 0f       	add	r18, r18
    148a:	33 1f       	adc	r19, r19
    148c:	28 0f       	add	r18, r24
    148e:	39 1f       	adc	r19, r25
    1490:	d9 01       	movw	r26, r18
    1492:	ab 53       	subi	r26, 0x3B	; 59
    1494:	b9 4f       	sbci	r27, 0xF9	; 249
    1496:	11 96       	adiw	r26, 0x01	; 1
    1498:	ed 91       	ld	r30, X+
    149a:	fc 91       	ld	r31, X
    149c:	12 97       	sbiw	r26, 0x02	; 2
    149e:	02 80       	ldd	r0, Z+2	; 0x02
    14a0:	f3 81       	ldd	r31, Z+3	; 0x03
    14a2:	e0 2d       	mov	r30, r0
    14a4:	12 96       	adiw	r26, 0x02	; 2
    14a6:	fc 93       	st	X, r31
    14a8:	ee 93       	st	-X, r30
    14aa:	11 97       	sbiw	r26, 0x01	; 1
    14ac:	28 53       	subi	r18, 0x38	; 56
    14ae:	39 4f       	sbci	r19, 0xF9	; 249
    14b0:	e2 17       	cp	r30, r18
    14b2:	f3 07       	cpc	r31, r19
    14b4:	29 f4       	brne	.+10     	; 0x14c0 <vTaskSwitchContext+0xac>
    14b6:	22 81       	ldd	r18, Z+2	; 0x02
    14b8:	33 81       	ldd	r19, Z+3	; 0x03
    14ba:	fd 01       	movw	r30, r26
    14bc:	32 83       	std	Z+2, r19	; 0x02
    14be:	21 83       	std	Z+1, r18	; 0x01
    14c0:	fc 01       	movw	r30, r24
    14c2:	ee 0f       	add	r30, r30
    14c4:	ff 1f       	adc	r31, r31
    14c6:	ee 0f       	add	r30, r30
    14c8:	ff 1f       	adc	r31, r31
    14ca:	ee 0f       	add	r30, r30
    14cc:	ff 1f       	adc	r31, r31
    14ce:	8e 0f       	add	r24, r30
    14d0:	9f 1f       	adc	r25, r31
    14d2:	fc 01       	movw	r30, r24
    14d4:	eb 53       	subi	r30, 0x3B	; 59
    14d6:	f9 4f       	sbci	r31, 0xF9	; 249
    14d8:	01 80       	ldd	r0, Z+1	; 0x01
    14da:	f2 81       	ldd	r31, Z+2	; 0x02
    14dc:	e0 2d       	mov	r30, r0
    14de:	86 81       	ldd	r24, Z+6	; 0x06
    14e0:	97 81       	ldd	r25, Z+7	; 0x07
    14e2:	90 93 f3 06 	sts	0x06F3, r25	; 0x8006f3 <pxCurrentTCB+0x1>
    14e6:	80 93 f2 06 	sts	0x06F2, r24	; 0x8006f2 <pxCurrentTCB>
    14ea:	08 95       	ret

000014ec <__divmodhi4>:
    14ec:	97 fb       	bst	r25, 7
    14ee:	07 2e       	mov	r0, r23
    14f0:	16 f4       	brtc	.+4      	; 0x14f6 <__divmodhi4+0xa>
    14f2:	00 94       	com	r0
    14f4:	07 d0       	rcall	.+14     	; 0x1504 <__divmodhi4_neg1>
    14f6:	77 fd       	sbrc	r23, 7
    14f8:	09 d0       	rcall	.+18     	; 0x150c <__divmodhi4_neg2>
    14fa:	0e 94 90 0a 	call	0x1520	; 0x1520 <__udivmodhi4>
    14fe:	07 fc       	sbrc	r0, 7
    1500:	05 d0       	rcall	.+10     	; 0x150c <__divmodhi4_neg2>
    1502:	3e f4       	brtc	.+14     	; 0x1512 <__divmodhi4_exit>

00001504 <__divmodhi4_neg1>:
    1504:	90 95       	com	r25
    1506:	81 95       	neg	r24
    1508:	9f 4f       	sbci	r25, 0xFF	; 255
    150a:	08 95       	ret

0000150c <__divmodhi4_neg2>:
    150c:	70 95       	com	r23
    150e:	61 95       	neg	r22
    1510:	7f 4f       	sbci	r23, 0xFF	; 255

00001512 <__divmodhi4_exit>:
    1512:	08 95       	ret

00001514 <__tablejump2__>:
    1514:	ee 0f       	add	r30, r30
    1516:	ff 1f       	adc	r31, r31
    1518:	05 90       	lpm	r0, Z+
    151a:	f4 91       	lpm	r31, Z
    151c:	e0 2d       	mov	r30, r0
    151e:	09 94       	ijmp

00001520 <__udivmodhi4>:
    1520:	aa 1b       	sub	r26, r26
    1522:	bb 1b       	sub	r27, r27
    1524:	51 e1       	ldi	r21, 0x11	; 17
    1526:	07 c0       	rjmp	.+14     	; 0x1536 <__udivmodhi4_ep>

00001528 <__udivmodhi4_loop>:
    1528:	aa 1f       	adc	r26, r26
    152a:	bb 1f       	adc	r27, r27
    152c:	a6 17       	cp	r26, r22
    152e:	b7 07       	cpc	r27, r23
    1530:	10 f0       	brcs	.+4      	; 0x1536 <__udivmodhi4_ep>
    1532:	a6 1b       	sub	r26, r22
    1534:	b7 0b       	sbc	r27, r23

00001536 <__udivmodhi4_ep>:
    1536:	88 1f       	adc	r24, r24
    1538:	99 1f       	adc	r25, r25
    153a:	5a 95       	dec	r21
    153c:	a9 f7       	brne	.-22     	; 0x1528 <__udivmodhi4_loop>
    153e:	80 95       	com	r24
    1540:	90 95       	com	r25
    1542:	bc 01       	movw	r22, r24
    1544:	cd 01       	movw	r24, r26
    1546:	08 95       	ret

00001548 <memset>:
    1548:	dc 01       	movw	r26, r24
    154a:	01 c0       	rjmp	.+2      	; 0x154e <memset+0x6>
    154c:	6d 93       	st	X+, r22
    154e:	41 50       	subi	r20, 0x01	; 1
    1550:	50 40       	sbci	r21, 0x00	; 0
    1552:	e0 f7       	brcc	.-8      	; 0x154c <memset+0x4>
    1554:	08 95       	ret

00001556 <strncpy>:
    1556:	fb 01       	movw	r30, r22
    1558:	dc 01       	movw	r26, r24
    155a:	41 50       	subi	r20, 0x01	; 1
    155c:	50 40       	sbci	r21, 0x00	; 0
    155e:	48 f0       	brcs	.+18     	; 0x1572 <strncpy+0x1c>
    1560:	01 90       	ld	r0, Z+
    1562:	0d 92       	st	X+, r0
    1564:	00 20       	and	r0, r0
    1566:	c9 f7       	brne	.-14     	; 0x155a <strncpy+0x4>
    1568:	01 c0       	rjmp	.+2      	; 0x156c <strncpy+0x16>
    156a:	1d 92       	st	X+, r1
    156c:	41 50       	subi	r20, 0x01	; 1
    156e:	50 40       	sbci	r21, 0x00	; 0
    1570:	e0 f7       	brcc	.-8      	; 0x156a <strncpy+0x14>
    1572:	08 95       	ret

00001574 <_exit>:
    1574:	f8 94       	cli

00001576 <__stop_program>:
    1576:	ff cf       	rjmp	.-2      	; 0x1576 <__stop_program>
